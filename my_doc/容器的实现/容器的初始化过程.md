## 容器的初始化过程

以最常见的[ClassPathXmlApplicationContext]的初始化过程为例介绍容器的初始化过程，[ClassPathXmlApplicationContext]创建方式如下:

```java
ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("xxxx.xml");
MyBeanA myBeanA = applicationContext.getBean("myBeanA", MyBeanA.class);
```

继承结构如下:
![ClassPathXmlApplicationContext继承结构图](../../img/ClassPathXmlApplicationContext.png)

下面介绍容器创建过程中涉及到的步骤：

1. 首先是[ClassPathXmlApplicationContext]的构造函数，代码：
   ```java
   public ClassPathXmlApplicationContext(String[] paths, Class<?> clazz, @Nullable ApplicationContext parent)
			throws BeansException {

		super(parent);
		Assert.notNull(paths, "Path array must not be null");
		Assert.notNull(clazz, "Class argument must not be null");
		this.configResources = new Resource[paths.length];
		for (int i = 0; i < paths.length; i++) {
			this.configResources[i] = new ClassPathResource(paths[i], clazz);
		}
		refresh();
	}
   ```
2. 构造函数调用了`refresh()`刷新容器，也就是开始创建容器，`refresh()`方法实现在[AbstractApplicationContext]，代码：
   ```java
   public void refresh() throws BeansException, IllegalStateException {
		synchronized (this.startupShutdownMonitor) {
			// Prepare this context for refreshing.
			// 初始化容器状态并对系统属性及环境变量进行验证
			prepareRefresh();

			// Tell the subclass to refresh the internal bean factory.
			// 初始化BeanFactory，解析资源文件注册BeanDefinition到BeanFactory
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

			// Prepare the bean factory for use in this context.
			// 初始化beanFactory的组件
			prepareBeanFactory(beanFactory);

			try {
				// Allows post-processing of the bean factory in context subclasses.
				// 供子类实现的方法，调用该方法时所有的bean definition都已经注册，但是所有的bean都还没有开始创建，此时可以添加自定义的BeanPostProcessor
				postProcessBeanFactory(beanFactory);

				// Invoke factory processors registered as beans in the context.
				// 调用注册的BeanFactoryPostProcessor和BeanFactoryPostProcessor的子接口BeanDefinitionRegistryPostProcessor
				// 即通知所有BeanDefinitionRegistryPostProcessor，当前BeanDefinitionRegistry注册事件，通知所有的BeanFactoryPostProcessor，当前
				// 的ConfigurableListableBeanFactory注册事件，该方法内部会调用beanFactory.getBean，所以从这里开始bean就可能开始初始化
				invokeBeanFactoryPostProcessors(beanFactory);

				// Register bean processors that intercept bean creation.
				// 注册所有的BeanPostProcessor到beanFactory中，上面的invokeBeanFactoryPostProcessors只会初始化所有的BeanFactoryPostProcessor和
				// BeanDefinitionRegistryPostProcessor类型的bean，这里查找所有的BeanPostProcessor类型的bean并初始化，同时也要注意如果一个BeanFactoryPostProcessor或
				// BeanDefinitionRegistryPostProcessor类型的bean依赖了其他的bean，在invokeBeanFactoryPostProcessors初始化这个BeanFactoryPostProcessor或
				// BeanDefinitionRegistryPostProcessor类型的bean时被依赖的bean会先于BeanFactoryPostProcessor或BeanDefinitionRegistryPostProcessor类型的bean
				// 创建，而此时所有的BeanPostProcessor都还没有被注册到beanFactory的beanPostProcessors列表中，所以这种情况下的BeanPostProcessor类型的bean的两个监听方法在初始化其他bean的时候不会被调用，
				// 如Bean A是BeanDefinitionRegistryPostProcessor类型的，Bean A有成员变量Bean B，Bean C是BeanPostProcessor，这种情况下Bean A在invokeBeanFactoryPostProcessors
				// 方法中被初始化并调用postProcessBeanFactory和postProcessBeanDefinitionRegistry方法，并会在初始化Bean A的时候先初始化Bean B，Bean C监听不到Bean B的创建，
				// 同样在registerBeanPostProcessors只是初始化了所有的BeanPostProcessor并添加到beanFactory中，所以BeanPostProcessor之间也是不会监听到创建，
				// 只有在registerBeanPostProcessors调用后BeanPostProcessor才会生效
				registerBeanPostProcessors(beanFactory);

				// Initialize message source for this context.
				// 初始化MessageSource
				initMessageSource();

				// Initialize event multicaster for this context.
				// 初始化ApplicationEventMulticaster，默认实现是SimpleApplicationEventMulticaster
				initApplicationEventMulticaster();

				// Initialize other special beans in specific context subclasses.
				// 供子类实现，可用于初始化自定义的bean或执行其他初始化工作，注意该方法执行的时候普通的bean还没有初始化
				onRefresh();

				// Check for listener beans and register them.
				// 初始化ApplicationListener类型的bean，并把保存在earlyApplicationEvents中的事件广播到所有的ApplicationListener，
				// 之后清空earlyApplicationEvents以便事件广播能够正常工作，earlyApplicationEvents的目的是在调用initApplicationEventMulticaster
				// 初始化ApplicationEventMulticaster之前保存被要求发布的事件
				registerListeners();

				// Instantiate all remaining (non-lazy-init) singletons.
				// 初始化剩余的非lazy-init的单例bean及ConversionService、LoadTimeWeaverAware等类型的bean
				finishBeanFactoryInitialization(beanFactory);

				// Last step: publish corresponding event.
				// 初始化lifecycleProcessor bean并调用lifecycleProcessor的onRefresh，发送ContextRefreshedEvent事件
				finishRefresh();
			}

			catch (BeansException ex) {
				if (logger.isWarnEnabled()) {
					logger.warn("Exception encountered during context initialization - " +
							"cancelling refresh attempt: " + ex);
				}

				// Destroy already created singletons to avoid dangling resources.
				destroyBeans();

				// Reset 'active' flag.
				cancelRefresh(ex);

				// Propagate exception to caller.
				throw ex;
			}

			finally {
				// Reset common introspection caches in Spring's core, since we
				// might not ever need metadata for singleton beans anymore...
				resetCommonCaches();
			}
		}
	}
   ```
   `refresh()`方法调用了若干方法完成容器的创建，下面依次说明各个方法的作用
- `prepareRefresh()`方法代码：
  ```java
  protected void prepareRefresh() {
		this.startupDate = System.currentTimeMillis();
		this.closed.set(false);
		this.active.set(true);

		if (logger.isInfoEnabled()) {
			logger.info("Refreshing " + this);
		}

		// Initialize any placeholder property sources in the context environment
		// 供子类实现，可以添加需要的PropertySources，PropertySources为PropertySource的集合，而PropertySource
		// 表示一个数据源，实现类如MapPropertySource接受一个Map并从Map中获取属性，ResourcePropertySource接受properties文件并从中获取属性，
		// ServletContextPropertySource的属性来自ServletContext上下文初始化参数等等
		initPropertySources();

		// Validate that all properties marked as required are resolvable
		// see ConfigurablePropertyResolver#setRequiredProperties
		// 验证必要的属性是否已经存在，即遍历environment中的requiredProperties属性，判断PropertySources中是否存在该属性
		getEnvironment().validateRequiredProperties();

		// Allow for the collection of early ApplicationEvents,
		// to be published once the multicaster is available...
		// 保存事件监听器初始化完成之前需要发送的事件，待监听器初始化完成后发送
		this.earlyApplicationEvents = new LinkedHashSet<>();
    }
  ```
- `obtainFreshBeanFactory()`方法代码：
  ```java
  protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
		// 刷新beanFactory，抽象方法
		refreshBeanFactory();

		ConfigurableListableBeanFactory beanFactory = getBeanFactory();
		if (logger.isDebugEnabled()) {
			logger.debug("Bean factory for " + getDisplayName() + ": " + beanFactory);
		}
		return beanFactory;
	}
  ```
  `refreshBeanFactory()`在[从XML加载Bean配置信息](从XML加载Bean配置信息.md)中有介绍，用于创建[BeanFactory]并将Bean配置信息注册到[BeanFactory]
- `prepareBeanFactory()`方法为[BeanFactory]初始化了若干组件，如：
   1. [BeanExpressionResolver]，用于解析`#{bean.xxx}`这样的SPEL表达式
   2. [PropertyEditorRegistrar]，用于在创建Bean时传入自定义的[PropertyEditor]，[PropertyEditor]的作用是完成字符串到具体类型的转换
   3. [ApplicationContextAwareProcessor]，[ApplicationContextAwareProcessor]对象是一个[BeanPostProcessor]，在创建Bean后执行回调方法，[ApplicationContextAwareProcessor]检查每个创建的bean是否是[EnvironmentAware]、[EmbeddedValueResolverAware]、[ResourceLoaderAware]、[ApplicationEventPublisherAware]、[MessageSourceAware]、[ApplicationContextAware]类型的，如果是则调用相应的setter方法，如setEnvironment
   4. 解析Bean依赖时需要忽略的接口类型，包括[EnvironmentAware]、[EmbeddedValueResolverAware]、[ResourceLoaderAware]、[ApplicationEventPublisherAware]、[MessageSourceAware]、[ApplicationContextAware]，即Spring在注入Bean成员变量时忽略这些类型的成员变量
   5. 添加可被依赖的类型，包括[BeanFactory]、[ResourceLoader]、[ApplicationEventPublisher]、[ApplicationContext]，Bean的这些成员变量将会被自动注入，除了[BeanFactory]注入的是[DefaultListableBeanFactory]，其他的都是[ClassPathXmlApplicationContext]本身
   6. [ApplicationListenerDetector]，[ApplicationListenerDetector]对象也是个[BeanPostProcessor]，用于检查创建的bean是否是[ApplicationListener]类型的，如果是并且是单例的则添加到`applicationListeners`中
   7. 如果[DefaultListableBeanFactory]包含`loadTimeWeaver`名字的Bean，则添加[BeanPostProcessor]实例[LoadTimeWeaverAwareProcessor]和一个`ClassLoader`实例[ContextTypeMatchClassLoader]
   8. 如果[DefaultListableBeanFactory]不包含`environment`名字的Bean，则注册一个[StandardEnvironment]实例为名字`environment`的单例Bean，同样这么处理的还有`systemProperties`和`systemEnvironment`名称的Bean
1. `postProcessBeanFactory()`方法供子类实现，用于添加自定义的[BeanPostProcessor]
2. `invokeBeanFactoryPostProcessors()`方法初始化并通知所有[BeanDefinitionRegistryPostProcessor]类型的Bean当前[BeanDefinitionRegistry]注册事件，初始化并通知所有的[BeanFactoryPostProcessor]类型的Bean当前[ConfigurableListableBeanFactory]注册事件，该方法内部会调用`beanFactory.getBean`初始化被创建的Bean的依赖，所以从这里开始普通的Bean就可能会被初始化
3. `registerBeanPostProcessors()`方法注册所有的[BeanPostProcessor]到[BeanFactory]中，上面的`invokeBeanFactoryPostProcessors()`方法只会初始化所有的[BeanFactoryPostProcessor]和[BeanDefinitionRegistryPostProcessor]类型的bean，这里查找所有的[BeanPostProcessor]类型的bean并初始化，同时也要注意如果一个[BeanFactoryPostProcessor]或[BeanDefinitionRegistryPostProcessor]类型的Bean依赖了其他的bean，在`invokeBeanFactoryPostProcessors()`方法初始化这个[BeanFactoryPostProcessor]或[BeanDefinitionRegistryPostProcessor]类型的Bean时被依赖的Bean会先于[BeanFactoryPostProcessor]或[BeanDefinitionRegistryPostProcessor]类型的Bean创建，而此时用户的[BeanPostProcessor]都还没有被注册到[BeanFactory]的`beanPostProcessors`列表中，所以这种情况下的[BeanPostProcessor]类型的Bean的两个监听方法不会被调用，如Bean A是[BeanDefinitionRegistryPostProcessor]类型的，Bean A有成员变量Bean B，Bean C是[BeanPostProcessor]，这种情况下Bean A在`invokeBeanFactoryPostProcessors()`方法中被初始化并调用`postProcessBeanFactory()`方法和`postProcessBeanDefinitionRegistry()`方法，并会在初始化Bean A的时候先初始化Bean B，Bean C监听不到Bean B的创建，同样在`registerBeanPostProcessors()`方法中只是初始化了所有的[BeanPostProcessor]并添加到[BeanFactory]中，所以[BeanPostProcessor]之间也是不会监听到彼此的创建，只有在`registerBeanPostProcessors()`方法调用后[BeanPostProcessor]才会生效
4. `initMessageSource()`方法初始化[MessageSource]，如果不存在`messageSource`名称的Bean，则创建[DelegatingMessageSource]作为默认的[MessageSource]，[MessageSource]用于支持国际化和参数的替换
5. `initApplicationEventMulticaster()`方法和[MessageSource]的初始化过程类似，初始化[ApplicationEventMulticaster]，如果不存在`applicationEventMulticaster`名称的Bean。则创建[SimpleApplicationEventMulticaster]作为默认实现
6.  `onRefresh()`方法，供子类实现，可用于初始化自定义的bean或执行其他初始化工作，注意该方法执行的时候大部分普通的Bean还没有初始化
7.  `registerListeners()`方法注册[ApplicationListener]类型的Bean到[ApplicationEventMulticaster]，并把保存在`earlyApplicationEvents`中的事件广播到所有的[ApplicationListener]，之后清空`earlyApplicationEvents`以便事件广播能够正常工作，`earlyApplicationEvents`的目的是在调用`initApplicationEventMulticaster()`方法初始化[ApplicationEventMulticaster]之前保存被要求发布的事件
8.  `finishBeanFactoryInitialization()`方法初始化剩余的非lazy-init的单例Bean及[ConversionService]、[LoadTimeWeaverAware]类型的Bean
9.  `finishRefresh()`方法初始化`lifecycleProcessor bean`(默认实现是[DefaultLifecycleProcessor])并调用`lifecycleProcessor`的`onRefresh()`方法，发送[ContextRefreshedEvent]事件(实现了[ApplicationContextEvent]接口])，事件由[ApplicationEventMulticaster]广播到所有的[ApplicationListener]
10. `resetCommonCaches()`方法清空所有容器的缓存，如注解解析、类解析等

[ClassPathXmlApplicationContext]: aaa
[BeanFactory]: aaa
[AbstractApplicationContext]: aaa
[BeanExpressionResolver]: aaa
[PropertyEditorRegistrar]: aaa
[PropertyEditor]: aaa
[ApplicationContextAwareProcessor]: aaa
[BeanPostProcessor]: aaa
[EnvironmentAware]: aaa
[EmbeddedValueResolverAware]: aaa
[ResourceLoaderAware]: aaa
[ApplicationEventPublisherAware]: aaa
[MessageSourceAware]: aaa
[ApplicationContextAware]: aaa
[DefaultListableBeanFactory]: aaa
[LoadTimeWeaverAwareProcessor]: aaa
[ContextTypeMatchClassLoader]: aaa
[StandardEnvironment]: aaa
[BeanDefinitionRegistryPostProcessor]: aaa
[BeanDefinitionRegistry]: aaa
[BeanFactoryPostProcessor]: aaa
[ConfigurableListableBeanFactory]: aaa
[MessageSource]: aaa
[DelegatingMessageSource]: aaa
[ApplicationEventMulticaster]: aaa
[SimpleApplicationEventMulticaster]: aaa
[DefaultLifecycleProcessor]: aaa
[ContextRefreshedEvent]: aaa
[ApplicationEventMulticaster]: aaa
[ApplicationContextEvent]: aaa
