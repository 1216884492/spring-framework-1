## 容器的初始化过程

以最常见的[ClassPathXmlApplicationContext]的初始化过程为例介绍容器的初始化过程，[ClassPathXmlApplicationContext]创建方式如下:

```java
ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("xxxx.xml");
MyBeanA myBeanA = applicationContext.getBean("myBeanA", MyBeanA.class);
```

继承结构如下:
![ClassPathXmlApplicationContext继承结构图](../../img/ClassPathXmlApplicationContext.png)

下面介绍容器创建过程中涉及到的步骤：

1. 首先[ClassPathXmlApplicationContext]的构造函数传入XML文件的路径，容器创建时首先解析该文件中的bean的配置信息并加载到[BeanFactory]中，而这一过程已经在[从XML加载Bean配置信息](从XML加载Bean配置信息)中介绍了，[AbstractApplicationContext]的`refresh()`方法在完成[从XML加载Bean配置信息](从XML加载Bean配置信息)后，会依次调用下面几个方法：
   1. prepareBeanFactory(beanFactory)
   2. postProcessBeanFactory(beanFactory);
   3. invokeBeanFactoryPostProcessors(beanFactory);
   4. registerBeanPostProcessors(beanFactory);
   5. initMessageSource();
   6. initApplicationEventMulticaster();
   7. onRefresh();
   8. registerListeners();
   9. finishBeanFactoryInitialization(beanFactory);
   10. finishRefresh();
   11. resetCommonCaches();
2. `prepareBeanFactory()`方法为[BeanFactory]初始化了若干组件，如：
   1. [BeanExpressionResolver]，用于解析`#{bean.xxx}`这样的SPEL表达式
   2. [PropertyEditorRegistrar]，用于在创建Bean时传入自定义的[PropertyEditor]，[PropertyEditor]的作用是完成字符串到具体类型的转换
   3. [ApplicationContextAwareProcessor]，[ApplicationContextAwareProcessor]对象是一个[BeanPostProcessor]，在创建Bean后执行回调方法，[ApplicationContextAwareProcessor]检查每个创建的bean是否是[EnvironmentAware]、[EmbeddedValueResolverAware]、[ResourceLoaderAware]、[ApplicationEventPublisherAware]、[MessageSourceAware]、[ApplicationContextAware]类型的，如果是则调用相应的setter方法，如setEnvironment
   4. 解析Bean依赖时需要忽略的接口类型，包括[EnvironmentAware]、[EmbeddedValueResolverAware]、[ResourceLoaderAware]、[ApplicationEventPublisherAware]、[MessageSourceAware]、[ApplicationContextAware]，即Spring在注入Bean成员变量时忽略这些类型的成员变量
   5. 添加可被依赖的类型，包括[BeanFactory]、[ResourceLoader]、[ApplicationEventPublisher]、[ApplicationContext]，Bean的这些成员变量将会被自动注入，除了[BeanFactory]注入的是[DefaultListableBeanFactory]，其他的都是[ClassPathXmlApplicationContext]本身
   6. [ApplicationListenerDetector]，[ApplicationListenerDetector]对象也是个[BeanPostProcessor]，用于检查创建的bean是否是[ApplicationListener]类型的，如果是并且是单例的则添加到`applicationListeners`中
   7. 如果[DefaultListableBeanFactory]包含`loadTimeWeaver`名字的Bean，则添加[BeanPostProcessor]实例[LoadTimeWeaverAwareProcessor]和一个`ClassLoader`实例[ContextTypeMatchClassLoader]
   8. 如果[DefaultListableBeanFactory]不包含`environment`名字的Bean，则注册一个[StandardEnvironment]实例为名字`environment`的单例Bean，同样这么处理的还有`systemProperties`和`systemEnvironment`名称的Bean
3. `postProcessBeanFactory()`方法供子类实现，用于添加自定义的[BeanPostProcessor]
4. `invokeBeanFactoryPostProcessors()`方法初始化并通知所有[BeanDefinitionRegistryPostProcessor]类型的Bean当前[BeanDefinitionRegistry]注册事件，初始化并通知所有的[BeanFactoryPostProcessor]类型的Bean当前[ConfigurableListableBeanFactory]注册事件，该方法内部会调用`beanFactory.getBean`初始化被创建的Bean的依赖，所以从这里开始普通的Bean就可能会被初始化
5. `registerBeanPostProcessors()`方法注册所有的[BeanPostProcessor]到[BeanFactory]中，上面的`invokeBeanFactoryPostProcessors()`方法只会初始化所有的[BeanFactoryPostProcessor]和[BeanDefinitionRegistryPostProcessor]类型的bean，这里查找所有的[BeanPostProcessor]类型的bean并初始化，同时也要注意如果一个[BeanFactoryPostProcessor]或[BeanDefinitionRegistryPostProcessor]类型的Bean依赖了其他的bean，在`invokeBeanFactoryPostProcessors()`方法初始化这个[BeanFactoryPostProcessor]或[BeanDefinitionRegistryPostProcessor]类型的Bean时被依赖的Bean会先于[BeanFactoryPostProcessor]或[BeanDefinitionRegistryPostProcessor]类型的Bean创建，而此时用户的[BeanPostProcessor]都还没有被注册到[BeanFactory]的`beanPostProcessors`列表中，所以这种情况下的[BeanPostProcessor]类型的Bean的两个监听方法不会被调用，如Bean A是[BeanDefinitionRegistryPostProcessor]类型的，Bean A有成员变量Bean B，Bean C是[BeanPostProcessor]，这种情况下Bean A在`invokeBeanFactoryPostProcessors()`方法中被初始化并调用`postProcessBeanFactory()`方法和`postProcessBeanDefinitionRegistry()`方法，并会在初始化Bean A的时候先初始化Bean B，Bean C监听不到Bean B的创建，同样在`registerBeanPostProcessors()`方法中只是初始化了所有的[BeanPostProcessor]并添加到[BeanFactory]中，所以[BeanPostProcessor]之间也是不会监听到彼此的创建，只有在`registerBeanPostProcessors()`方法调用后[BeanPostProcessor]才会生效
6. `initMessageSource()`方法初始化[MessageSource]，如果不存在`messageSource`名称的Bean，则创建[DelegatingMessageSource]作为默认的[MessageSource]，[MessageSource]用于支持国际化和参数的替换
7. `initApplicationEventMulticaster()`方法和[MessageSource]的初始化过程类似，初始化[ApplicationEventMulticaster]，如果不存在`applicationEventMulticaster`名称的Bean。则创建[SimpleApplicationEventMulticaster]作为默认实现
8. `onRefresh()`方法，供子类实现，可用于初始化自定义的bean或执行其他初始化工作，注意该方法执行的时候大部分普通的Bean还没有初始化
9. `registerListeners()`方法注册[ApplicationListener]类型的Bean到[ApplicationEventMulticaster]，并把保存在`earlyApplicationEvents`中的事件广播到所有的[ApplicationListener]，之后清空`earlyApplicationEvents`以便事件广播能够正常工作，`earlyApplicationEvents`的目的是在调用`initApplicationEventMulticaster()`方法初始化[ApplicationEventMulticaster]之前保存被要求发布的事件
10. `finishBeanFactoryInitialization()`方法初始化剩余的非lazy-init的单例Bean及[ConversionService]、[LoadTimeWeaverAware]类型的Bean
11. `finishRefresh()`方法初始化`lifecycleProcessor bean`(默认实现是[DefaultLifecycleProcessor])并调用`lifecycleProcessor`的`onRefresh()`方法，发送[ContextRefreshedEvent]事件(实现了[ApplicationContextEvent]接口])，事件由[ApplicationEventMulticaster]广播到所有的[ApplicationListener]
12. `resetCommonCaches()`方法清空所有容器的缓存，如注解解析、类解析等

[ClassPathXmlApplicationContext]: aaa
[BeanFactory]: aaa
[AbstractApplicationContext]: aaa
[BeanExpressionResolver]: aaa
[PropertyEditorRegistrar]: aaa
[PropertyEditor]: aaa
[ApplicationContextAwareProcessor]: aaa
[BeanPostProcessor]: aaa
[EnvironmentAware]: aaa
[EmbeddedValueResolverAware]: aaa
[ResourceLoaderAware]: aaa
[ApplicationEventPublisherAware]: aaa
[MessageSourceAware]: aaa
[ApplicationContextAware]: aaa
[DefaultListableBeanFactory]: aaa
[LoadTimeWeaverAwareProcessor]: aaa
[ContextTypeMatchClassLoader]: aaa
[StandardEnvironment]: aaa
[BeanDefinitionRegistryPostProcessor]: aaa
[BeanDefinitionRegistry]: aaa
[BeanFactoryPostProcessor]: aaa
[ConfigurableListableBeanFactory]: aaa
[MessageSource]: aaa
[DelegatingMessageSource]: aaa
[ApplicationEventMulticaster]: aaa
[SimpleApplicationEventMulticaster]: aaa
[DefaultLifecycleProcessor]: aaa
[ContextRefreshedEvent]: aaa
[ApplicationEventMulticaster]: aaa
[ApplicationContextEvent]: aaa
