首先看一个事务回滚的测试用例：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	   xmlns:tx="http://www.springframework.org/schema/tx"
	   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd

       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd">

	<tx:annotation-driven/>

	<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource"/>
	</bean>

	<bean id="bookDao" class="org.springframework.transaction.annotation.dhf.book.dao.impl.JdbcTemplateBookDao">
		<property name="dataSource" ref="dataSource"/>
	</bean>

</beans>
```

```java
public class MyAnnotationTransactionTests {
	ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("org/springframework/transaction/annotation/dhf/MyAnnotationTransactionTests.xml");
	@Test
	public void baseTest() {
		BookDao bookDao = (BookDao) context.getBean("bookDao");
		System.out.println(bookDao.getAll());
	}

	@Test
	public void requestTest() {
		BookDao bookDao = (BookDao) context.getBean("bookDao");
		int count = bookDao.getAll().size();
		System.out.println("count: " + count);

		try {
			System.out.println("insertWithException");
			bookDao.insertWithException(new Book() {{
				setName("test");
				setYear(1);
			}});
		} catch (Exception e) {
			System.out.println(e.getMessage());;
		}

		count = bookDao.getAll().size();
		System.out.println("count: " + count);

		try {
			System.out.println("insert");
			bookDao.insert(new Book() {{
				setName("test");
				setYear(1);
			}});
		} catch (Exception e) {
			e.printStackTrace();
		}

		count = bookDao.getAll().size();
		System.out.println("count: " + count);
	}
}

/*
输出：
count: 5
insertWithException
test insert exception
count: 5
insert
count: 6
*/
```

上面用到的[BookDao]接口及用到的`insert()`和`insertWithException()`方法代码：
```java
@Transactional(propagation = Propagation.REQUIRED)
public interface BookDao {
    void insert(Book book);

    void insertWithException(Book book);

    void insertBatch(List<Book> books);

    void delete(Book book);

    void deleteAll();

    Book getById(Integer id);

    List<Book> getAll();
}

@Override
public void insert(Book book) {
    String sql = "INSERT INTO BOOK(BOOK_ID, NAME, YEAR) VALUES (?, ?, ?)";

    getJdbcTemplate().update(sql, new Object[]{book.getBookId(), book.getName(), book.getYear()});
}
@Override
public void insertWithException(Book book) {
    String sql = "INSERT INTO BOOK(BOOK_ID, NAME, YEAR) VALUES (?, ?, ?)";

    getJdbcTemplate().update(sql, new Object[]{book.getBookId(), book.getName(), book.getYear()});
    throw new RuntimeException("test insert exception");
}
```

可以看到，当insert后抛出异常，数据不会被插入到数据库，即数据库回滚了，而正常执行的insert成功插入了，下面分析Spring中事务的实现原理，首先和AOP一样，先找到XML中`tx`对应的[NamespaceHandler]，其实现是[TxNamespaceHandler]，代码：
```java
public class TxNamespaceHandler extends NamespaceHandlerSupport {

	static final String TRANSACTION_MANAGER_ATTRIBUTE = "transaction-manager";

	// 默认事务管理器的bean name
  static final String DEFAULT_TRANSACTION_MANAGER_BEAN_NAME = "transactionManager";


	static String getTransactionManagerName(Element element) {
		return (element.hasAttribute(TRANSACTION_MANAGER_ATTRIBUTE) ?
				element.getAttribute(TRANSACTION_MANAGER_ATTRIBUTE) : DEFAULT_TRANSACTION_MANAGER_BEAN_NAME);
	}


	@Override
	public void init() {
		registerBeanDefinitionParser("advice", new TxAdviceBeanDefinitionParser());
		registerBeanDefinitionParser("annotation-driven", new AnnotationDrivenBeanDefinitionParser());
		registerBeanDefinitionParser("jta-transaction-manager", new JtaTransactionManagerBeanDefinitionParser());
	}

}
```

`annotation-driven`对应的解析类是[AnnotationDrivenBeanDefinitionParser]，代码：
```java
class AnnotationDrivenBeanDefinitionParser implements BeanDefinitionParser {
	@Override
	@Nullable
	public BeanDefinition parse(Element element, ParserContext parserContext) {
		registerTransactionalEventListenerFactory(parserContext);
		String mode = element.getAttribute("mode");
		if ("aspectj".equals(mode)) {
			// 如果设置mode为aspectj则使用aspectj创建代理
			// mode="aspectj"
			registerTransactionAspect(element, parserContext);
		}
		else {
			// mode="proxy"
			AopAutoProxyConfigurer.configureAutoProxyCreator(element, parserContext);
		}
		return null;
	}

	private void registerTransactionAspect(Element element, ParserContext parserContext) {
		String txAspectBeanName = TransactionManagementConfigUtils.TRANSACTION_ASPECT_BEAN_NAME;
		String txAspectClassName = TransactionManagementConfigUtils.TRANSACTION_ASPECT_CLASS_NAME;
		if (!parserContext.getRegistry().containsBeanDefinition(txAspectBeanName)) {
			RootBeanDefinition def = new RootBeanDefinition();
			def.setBeanClassName(txAspectClassName);
			def.setFactoryMethodName("aspectOf");
			registerTransactionManager(element, def);
			parserContext.registerBeanComponent(new BeanComponentDefinition(def, txAspectBeanName));
		}
	}

	private static void registerTransactionManager(Element element, BeanDefinition def) {
		def.getPropertyValues().add("transactionManagerBeanName",
				TxNamespaceHandler.getTransactionManagerName(element));
	}

	private void registerTransactionalEventListenerFactory(ParserContext parserContext) {
		RootBeanDefinition def = new RootBeanDefinition();
		def.setBeanClass(TransactionalEventListenerFactory.class);
		parserContext.registerBeanComponent(new BeanComponentDefinition(def,
				TransactionManagementConfigUtils.TRANSACTIONAL_EVENT_LISTENER_FACTORY_BEAN_NAME));
	}

	private static class AopAutoProxyConfigurer {
		public static void configureAutoProxyCreator(Element element, ParserContext parserContext) {
			// 事务的实现是基于aop的，这里添加InfrastructureAdvisorAutoProxyCreator的BeanDefinition到BeanFactory，InfrastructureAdvisorAutoProxyCreator
			// 能够将role为ROLE_INFRASTRUCTURE并且实现了Advisor接口的bean添加到aop的可用advisor列表中
			AopNamespaceUtils.registerAutoProxyCreatorIfNecessary(parserContext, element);

			String txAdvisorBeanName = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME;
			if (!parserContext.getRegistry().containsBeanDefinition(txAdvisorBeanName)) {
				Object eleSource = parserContext.extractSource(element);

				// Create the TransactionAttributeSource definition.
				// 注册class为AnnotationTransactionAttributeSource的bean
				RootBeanDefinition sourceDef = new RootBeanDefinition(
						"org.springframework.transaction.annotation.AnnotationTransactionAttributeSource");
				sourceDef.setSource(eleSource);
				sourceDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
				// 注册BeanDefinition到BeanFactory，用DefaultBeanNameGenerator生成bean name，默认为className#0
				String sourceName = parserContext.getReaderContext().registerWithGeneratedName(sourceDef);

				// Create the TransactionInterceptor definition.
				// 注册class为TransactionInterceptor的bean
				RootBeanDefinition interceptorDef = new RootBeanDefinition(TransactionInterceptor.class);
				interceptorDef.setSource(eleSource);
				interceptorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
				// 将<tx:annotation-driven/>中的transaction-manager属性添加到该bean的PropertyValues中，如果没有则默认为transactionManager
				registerTransactionManager(element, interceptorDef);
				// 添加transactionAttributeSource属性为上面注册的AnnotationTransactionAttributeSource的引用
				interceptorDef.getPropertyValues().add("transactionAttributeSource", new RuntimeBeanReference(sourceName));
				String interceptorName = parserContext.getReaderContext().registerWithGeneratedName(interceptorDef);

				// Create the TransactionAttributeSourceAdvisor definition.
				// 注册class为BeanFactoryTransactionAttributeSourceAdvisor的bean，BeanFactoryTransactionAttributeSourceAdvisor实现了Advisor接口
				RootBeanDefinition advisorDef = new RootBeanDefinition(BeanFactoryTransactionAttributeSourceAdvisor.class);
				advisorDef.setSource(eleSource);
				advisorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
				// 添加上面注册的两个bean到下面两个属性中
				advisorDef.getPropertyValues().add("transactionAttributeSource", new RuntimeBeanReference(sourceName));
				advisorDef.getPropertyValues().add("adviceBeanName", interceptorName);
				if (element.hasAttribute("order")) {
					advisorDef.getPropertyValues().add("order", element.getAttribute("order"));
				}
				// 注册BeanDefinition
				parserContext.getRegistry().registerBeanDefinition(txAdvisorBeanName, advisorDef);

				// 发起上面3个BeanDefinition的注册事件
				CompositeComponentDefinition compositeDef = new CompositeComponentDefinition(element.getTagName(), eleSource);
				compositeDef.addNestedComponent(new BeanComponentDefinition(sourceDef, sourceName));
				compositeDef.addNestedComponent(new BeanComponentDefinition(interceptorDef, interceptorName));
				compositeDef.addNestedComponent(new BeanComponentDefinition(advisorDef, txAdvisorBeanName));
				parserContext.registerComponent(compositeDef);
			}
		}
	}

}
```

[AnnotationDrivenBeanDefinitionParser]一共注册了4个[BeanDefinition]，其中[AnnotationTransactionAttributeSource]和[TransactionInterceptor]都被设置为[BeanFactoryTransactionAttributeSourceAdvisor]的属性，所以先从[BeanFactoryTransactionAttributeSourceAdvisor]的代码入手，下面是[BeanFactoryTransactionAttributeSourceAdvisor]的继承结构：
![BeanFactoryTransactionAttributeSourceAdvisor继承结构](../img/BeanFactoryTransactionAttributeSourceAdvisor.png)

[BeanFactoryTransactionAttributeSourceAdvisor]实现了[Advisor]接口，[AnnotationDrivenBeanDefinitionParser]中注册的[InfrastructureAdvisorAutoProxyCreator]会在创建bean时获取所有实现了[Advisor]接口的Bean以创建其他Bean的代理，所以创建普通Bean时[BeanFactoryTransactionAttributeSourceAdvisor]会被作为[Advisor]参与Bean的代理创建过程，[BeanFactoryTransactionAttributeSourceAdvisor]作为[Advisor]时涉及到的方法有：
```java
private final TransactionAttributeSourcePointcut pointcut = new TransactionAttributeSourcePointcut() {
  @Override
  @Nullable
  protected TransactionAttributeSource getTransactionAttributeSource() {
    return transactionAttributeSource;
  }
};

@Override
public Pointcut getPointcut() {
  return this.pointcut;
}

@Override
public Advice getAdvice() {
  Advice advice = this.advice;
  if (advice != null) {
    return advice;
  }

  // 如果Advice还未初始化则根据adviceBeanName获取Advice
  Assert.state(this.adviceBeanName != null, "'adviceBeanName' must be specified");
  Assert.state(this.beanFactory != null, "BeanFactory must be set to resolve 'adviceBeanName'");

  if (this.beanFactory.isSingleton(this.adviceBeanName)) {
    // Rely on singleton semantics provided by the factory.
    advice = this.beanFactory.getBean(this.adviceBeanName, Advice.class);
    this.advice = advice;
    return advice;
  }
  else {
    // No singleton guarantees from the factory -> let's lock locally but
    // reuse the factory's singleton lock, just in case a lazy dependency
    // of our advice bean happens to trigger the singleton lock implicitly...
    synchronized (this.adviceMonitor) {
      advice = this.advice;
      if (advice == null) {
        advice = this.beanFactory.getBean(this.adviceBeanName, Advice.class);
        this.advice = advice;
      }
      return advice;
    }
  }
}
```

其中`adviceBeanName`属性就是[AnnotationDrivenBeanDefinitionParser]中注册的[TransactionInterceptor]的bean name，从笔记[如何实现AOP](如何实现AOP.md)可知，创建Bean代理之前，[AbstractAdvisorAutoProxyCreator]类的`findEligibleAdvisors()`方法会遍历所有的[Advisor]并过滤掉不匹配正在创建的Bean的[Advisor]，过滤过程会根据[Advisor]的类型执行不同的逻辑，对于[BeanFactoryTransactionAttributeSourceAdvisor]类，其实现了[PointcutAdvisor]接口，所以过滤时会调用[BeanFactoryTransactionAttributeSourceAdvisor]的`getPointcut()`方法获取[Pointcut]并通过[Pointcut]类判断[Advisor]的适用性，而[BeanFactoryTransactionAttributeSourceAdvisor]的[Pointcut]就是匿名的[TransactionAttributeSourcePointcut]实现类，实现`getTransactionAttributeSource()`方法返回[BeanFactoryTransactionAttributeSourceAdvisor]中的`transactionAttributeSource`属性，也就是[AnnotationDrivenBeanDefinitionParser]中注册的[AnnotationTransactionAttributeSource]，下面先看[TransactionAttributeSourcePointcut]的实现，下面是[TransactionAttributeSourcePointcut]的继承结构：
![TransactionAttributeSourcePointcut的继承结构](../img/TransactionAttributeSourcePointcut.png)

[StaticMethodMatcher]定义了一个静态的[MethodMatcher]的基本实现，即匹配结果不受方法参数的影响，代码：
```java
public abstract class StaticMethodMatcher implements MethodMatcher {

	@Override
	public final boolean isRuntime() {
		// 表示当前MethodMatcher
		return false;
	}

	@Override
	public final boolean matches(Method method, @Nullable Class<?> targetClass, Object... args) {
		// should never be invoked because isRuntime() returns false
		throw new UnsupportedOperationException("Illegal MethodMatcher usage");
	}

}
```

[StaticMethodMatcherPointcut]类实现了基本的get、set方法
```java
public abstract class StaticMethodMatcherPointcut extends StaticMethodMatcher implements Pointcut {

	private ClassFilter classFilter = ClassFilter.TRUE;

	public void setClassFilter(ClassFilter classFilter) {
		this.classFilter = classFilter;
	}

	@Override
	public ClassFilter getClassFilter() {
		return this.classFilter;
	}


	@Override
	public final MethodMatcher getMethodMatcher() {
		// StaticMethodMatcherPointcut类实现了MethodMatcher接口，所以这里直接把自己作为MethodMatcher返回
		return this;
	}

}
```

下面是[TransactionAttributeSourcePointcut]的代码：
```java
@SuppressWarnings("serial")
abstract class TransactionAttributeSourcePointcut extends StaticMethodMatcherPointcut implements Serializable {

	@Override
	public boolean matches(Method method, @Nullable Class<?> targetClass) {
		// 如果bean本身是个代理，则不匹配
		if (targetClass != null && TransactionalProxy.class.isAssignableFrom(targetClass)) {
			return false;
		}
		// 返回的实际上就是AnnotationTransactionAttributeSource
		TransactionAttributeSource tas = getTransactionAttributeSource();
		// 如果AnnotationTransactionAttributeSource能够从方法中获取到TransactionAttribute实例则表示该方法需要被代理，即匹配成功
		return (tas == null || tas.getTransactionAttribute(method, targetClass) != null);
	}

	@Override
	public boolean equals(Object other) {
		if (this == other) {
			return true;
		}
		if (!(other instanceof TransactionAttributeSourcePointcut)) {
			return false;
		}
		TransactionAttributeSourcePointcut otherPc = (TransactionAttributeSourcePointcut) other;
		return ObjectUtils.nullSafeEquals(getTransactionAttributeSource(), otherPc.getTransactionAttributeSource());
	}

	@Override
	public int hashCode() {
		return TransactionAttributeSourcePointcut.class.hashCode();
	}

	@Override
	public String toString() {
		return getClass().getName() + ": " + getTransactionAttributeSource();
	}

	@Nullable
	protected abstract TransactionAttributeSource getTransactionAttributeSource();

}
```

所以下面需要看[AnnotationTransactionAttributeSource]的实现，下面是[AnnotationTransactionAttributeSource]的继承结构：
![AnnotationTransactionAttributeSource的继承结构](../img/AnnotationTransactionAttributeSource.png)

[TransactionAttributeSource]接口代码：
```java
public interface TransactionAttributeSource {
	@Nullable
	TransactionAttribute getTransactionAttribute(Method method, @Nullable Class<?> targetClass);
}
```

[TransactionAttribute]的作用是返回方法上的事务属性，代码：
```java
public interface TransactionAttribute extends TransactionDefinition {
	@Nullable
	// 返回事务的qualifier值，即Transactional注解的transactionManager属性值，用于选择事务对应的transactionManager
	String getQualifier();

	// 判断传入的异常是否需要回滚
	boolean rollbackOn(Throwable ex);
}
```

[AbstractFallbackTransactionAttributeSource]抽象类实现了获取[TransactionAttribute]的基本逻辑，具体获取[TransactionAttribute]的实现由子类实现，代码：
```java
public abstract class AbstractFallbackTransactionAttributeSource implements TransactionAttributeSource {
	private static final TransactionAttribute NULL_TRANSACTION_ATTRIBUTE = new DefaultTransactionAttribute();

	protected final Log logger = LogFactory.getLog(getClass());

	// TransactionAttribute的缓存，key为执行方法和方法所在类组成的对象
	private final Map<Object, TransactionAttribute> attributeCache = new ConcurrentHashMap<>(1024);

	@Override
	@Nullable
	public TransactionAttribute getTransactionAttribute(Method method, @Nullable Class<?> targetClass) {
		if (method.getDeclaringClass() == Object.class) {
			return null;
		}

		// First, see if we have a cached value.
		Object cacheKey = getCacheKey(method, targetClass);
		Object cached = this.attributeCache.get(cacheKey);
		// 先尝试从缓存中获取
		if (cached != null) {
			// Value will either be canonical value indicating there is no transaction attribute,
			// or an actual transaction attribute.
			// 如果缓存中保存的是NULL_TRANSACTION_ATTRIBUTE则说明之前判断过了该方法不需要事务
			if (cached == NULL_TRANSACTION_ATTRIBUTE) {
				return null;
			}
			else {
				return (TransactionAttribute) cached;
			}
		}
		else {
			// We need to work it out.
			// 创建TransactionAttribute
			TransactionAttribute txAttr = computeTransactionAttribute(method, targetClass);
			// Put it in the cache.
			if (txAttr == null) {
				// 如果txAttr为空，则保存NULL_TRANSACTION_ATTRIBUTE到缓存，下次在获取时直接返回null
				this.attributeCache.put(cacheKey, NULL_TRANSACTION_ATTRIBUTE);
			}
			else {
				// 获取方法的唯一名称，由全类名.方法名组成
				String methodIdentification = ClassUtils.getQualifiedMethodName(method, targetClass);
				if (txAttr instanceof DefaultTransactionAttribute) {
					((DefaultTransactionAttribute) txAttr).setDescriptor(methodIdentification);
				}
				if (logger.isDebugEnabled()) {
					logger.debug("Adding transactional method '" + methodIdentification + "' with attribute: " + txAttr);
				}
				// 结果保存到缓存中
				this.attributeCache.put(cacheKey, txAttr);
			}
			return txAttr;
		}
	}

	protected Object getCacheKey(Method method, @Nullable Class<?> targetClass) {
		return new MethodClassKey(method, targetClass);
	}

	@Nullable
	protected TransactionAttribute computeTransactionAttribute(Method method, @Nullable Class<?> targetClass) {
		// Don't allow no-public methods as required.
		// 默认情况下非public的方法不执行事务
		if (allowPublicMethodsOnly() && !Modifier.isPublic(method.getModifiers())) {
			return null;
		}

		// The method may be on an interface, but we need attributes from the target class.
		// If the target class is null, the method will be unchanged.
		// 如果method的声明类不是specificTargetClass，则从specificTargetClass开始获取实现了method方法的类并返回该方法，即
		// 获取最具体的方法实现
		Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);

		// First try is the method in the target class.
		// 供子类实现，获取方法上的TransactionAttribute属性，如果返回值不为空则直接返回
		TransactionAttribute txAttr = findTransactionAttribute(specificMethod);
		if (txAttr != null) {
			return txAttr;
		}

		// Second try is the transaction attribute on the target class.
		txAttr = findTransactionAttribute(specificMethod.getDeclaringClass());
		// 供子类实现，获取类上的TransactionAttribute属性，如果返回值不为空并且方法是用户创建的而不是桥接方法等自动生成的方法，则直接返回
		if (txAttr != null && ClassUtils.isUserLevelMethod(method)) {
			return txAttr;
		}

		// 如果没从子类获取到TransactionAttribute，则再使用原始的方法获取一次
		if (specificMethod != method) {
			// Fallback is to look at the original method.
			txAttr = findTransactionAttribute(method);
			if (txAttr != null) {
				return txAttr;
			}
			// Last fallback is the class of the original method.
			txAttr = findTransactionAttribute(method.getDeclaringClass());
			if (txAttr != null && ClassUtils.isUserLevelMethod(method)) {
				return txAttr;
			}
		}

		return null;
	}

	@Nullable
	protected abstract TransactionAttribute findTransactionAttribute(Method method);

	@Nullable
	protected abstract TransactionAttribute findTransactionAttribute(Class<?> clazz);

	// 是否只有public方法才能执行事务
	protected boolean allowPublicMethodsOnly() {
		return false;
	}

}
```

最后是[AnnotationTransactionAttributeSource]的实现，代码：
```java
@SuppressWarnings("serial")
public class AnnotationTransactionAttributeSource extends AbstractFallbackTransactionAttributeSource
		implements Serializable {

	// 判断是否使用了javax.transaction.Transactional注解，如果是则在获取TransactionAttributeSource时需要使用相应的解析类获取
	private static final boolean jta12Present = ClassUtils.isPresent(
			"javax.transaction.Transactional", AnnotationTransactionAttributeSource.class.getClassLoader());

	// 同上
	private static final boolean ejb3Present = ClassUtils.isPresent(
			"javax.ejb.TransactionAttribute", AnnotationTransactionAttributeSource.class.getClassLoader());

	private final boolean publicMethodsOnly;

	// TransactionAnnotationParser根据注解获取TransactionAttributeSource
	private final Set<TransactionAnnotationParser> annotationParsers;

	public AnnotationTransactionAttributeSource() {
		this(true);
	}

	public AnnotationTransactionAttributeSource(boolean publicMethodsOnly) {
		this.publicMethodsOnly = publicMethodsOnly;
		this.annotationParsers = new LinkedHashSet<>(2);
		// Spring的Transactional注解的解析类
		this.annotationParsers.add(new SpringTransactionAnnotationParser());
		// javax.transaction.Transactional注解的解析类
		if (jta12Present) {
			this.annotationParsers.add(new JtaTransactionAnnotationParser());
		}
		// javax.ejb.TransactionAttribute注解的解析类
		if (ejb3Present) {
			this.annotationParsers.add(new Ejb3TransactionAnnotationParser());
		}
	}
	
	public AnnotationTransactionAttributeSource(TransactionAnnotationParser annotationParser) {
		this.publicMethodsOnly = true;
		Assert.notNull(annotationParser, "TransactionAnnotationParser must not be null");
		this.annotationParsers = Collections.singleton(annotationParser);
	}
	
	public AnnotationTransactionAttributeSource(TransactionAnnotationParser... annotationParsers) {
		this.publicMethodsOnly = true;
		Assert.notEmpty(annotationParsers, "At least one TransactionAnnotationParser needs to be specified");
		Set<TransactionAnnotationParser> parsers = new LinkedHashSet<>(annotationParsers.length);
		Collections.addAll(parsers, annotationParsers);
		this.annotationParsers = parsers;
	}

	public AnnotationTransactionAttributeSource(Set<TransactionAnnotationParser> annotationParsers) {
		this.publicMethodsOnly = true;
		Assert.notEmpty(annotationParsers, "At least one TransactionAnnotationParser needs to be specified");
		this.annotationParsers = annotationParsers;
	}


	@Override
	@Nullable
	protected TransactionAttribute findTransactionAttribute(Method method) {
		return determineTransactionAttribute(method);
	}

	@Override
	@Nullable
	protected TransactionAttribute findTransactionAttribute(Class<?> clazz) {
		return determineTransactionAttribute(clazz);
	}

	@Nullable
	protected TransactionAttribute determineTransactionAttribute(AnnotatedElement ae) {
		for (TransactionAnnotationParser annotationParser : this.annotationParsers) {
			TransactionAttribute attr = annotationParser.parseTransactionAnnotation(ae);
			if (attr != null) {
				return attr;
			}
		}
		return null;
	}

	@Override
	protected boolean allowPublicMethodsOnly() {
		return this.publicMethodsOnly;
	}


	@Override
	public boolean equals(Object other) {
		if (this == other) {
			return true;
		}
		if (!(other instanceof AnnotationTransactionAttributeSource)) {
			return false;
		}
		AnnotationTransactionAttributeSource otherTas = (AnnotationTransactionAttributeSource) other;
		return (this.annotationParsers.equals(otherTas.annotationParsers) &&
				this.publicMethodsOnly == otherTas.publicMethodsOnly);
	}

	@Override
	public int hashCode() {
		return this.annotationParsers.hashCode();
	}

}
```

[AnnotationTransactionAttributeSource]内部定义了多个[TransactionAnnotationParser]的实现，获取[TransactionAttribute]实际上就是这些[TransactionAnnotationParser]的实现的，以Spring的[Transactional]注解为例，实现是[SpringTransactionAnnotationParser]类，[SpringTransactionAnnotationParser]解析注解属性并将这些属性保存到[RuleBasedTransactionAttribute]实例中并返回，代码：
```java
@SuppressWarnings("serial")
public class SpringTransactionAnnotationParser implements TransactionAnnotationParser, Serializable {

	@Override
	@Nullable
	public TransactionAttribute parseTransactionAnnotation(AnnotatedElement ae) {
		// 合并注解的属性，方法上的Transactional注解属性会覆盖类上的属性
		AnnotationAttributes attributes = AnnotatedElementUtils.findMergedAnnotationAttributes(
				ae, Transactional.class, false, false);
		if (attributes != null) {
			return parseTransactionAnnotation(attributes);
		}
		else {
			return null;
		}
	}

	public TransactionAttribute parseTransactionAnnotation(Transactional ann) {
		return parseTransactionAnnotation(AnnotationUtils.getAnnotationAttributes(ann, false, false));
	}

	protected TransactionAttribute parseTransactionAnnotation(AnnotationAttributes attributes) {
		// 创建RuleBasedTransactionAttribute类，并为RuleBasedTransactionAttribute设置传入的注解的若干属性值
		RuleBasedTransactionAttribute rbta = new RuleBasedTransactionAttribute();
		Propagation propagation = attributes.getEnum("propagation");
		rbta.setPropagationBehavior(propagation.value());
		Isolation isolation = attributes.getEnum("isolation");
		rbta.setIsolationLevel(isolation.value());
		rbta.setTimeout(attributes.getNumber("timeout").intValue());
		rbta.setReadOnly(attributes.getBoolean("readOnly"));
		rbta.setQualifier(attributes.getString("value"));
		ArrayList<RollbackRuleAttribute> rollBackRules = new ArrayList<>();
		Class<?>[] rbf = attributes.getClassArray("rollbackFor");
		for (Class<?> rbRule : rbf) {
			// rbf表示所有应该被回滚的异常，这里用RollbackRuleAttribute封装异常类并保存到RuleBasedTransactionAttribute中
			RollbackRuleAttribute rule = new RollbackRuleAttribute(rbRule);
			rollBackRules.add(rule);
		}
		String[] rbfc = attributes.getStringArray("rollbackForClassName");
		for (String rbRule : rbfc) {
			// 同上
			RollbackRuleAttribute rule = new RollbackRuleAttribute(rbRule);
			rollBackRules.add(rule);
		}
		Class<?>[] nrbf = attributes.getClassArray("noRollbackFor");
		for (Class<?> rbRule : nrbf) {
			// nrbf表示所有不应该被回滚的异常
			NoRollbackRuleAttribute rule = new NoRollbackRuleAttribute(rbRule);
			rollBackRules.add(rule);
		}
		String[] nrbfc = attributes.getStringArray("noRollbackForClassName");
		for (String rbRule : nrbfc) {
			// 同上
			NoRollbackRuleAttribute rule = new NoRollbackRuleAttribute(rbRule);
			rollBackRules.add(rule);
		}
		rbta.getRollbackRules().addAll(rollBackRules);
		return rbta;
	}

	@Override
	public boolean equals(Object other) {
		return (this == other || other instanceof SpringTransactionAnnotationParser);
	}

	@Override
	public int hashCode() {
		return SpringTransactionAnnotationParser.class.hashCode();
	}

}
```

以上是针对[BeanFactoryTransactionAttributeSourceAdvisor]实现的`getPointcut()`方法，对于[Pointcut]，只是Spring中AOP的验证，而代理的实现则是[Advice]，[BeanFactoryTransactionAttributeSourceAdvisor]返回的[Advice]是[TransactionInterceptor]，下面在分析[TransactionInterceptor]的实现，下面是[TransactionInterceptor]的继承结构：
![TransactionInterceptor继承结构](../img/TransactionInterceptor.png)

如果看过笔记[从容器获取Bean](从容器获取Bean.md)和[如何实现AOP](如何实现AOP.md)，那对上面的接口不会默认，所以下面直接看实现类，首先是[TransactionAspectSupport]，代码：
```java

```

[NamespaceHandler]: aaa
[AnnotationDrivenBeanDefinitionParser]: aaa
[AnnotationTransactionAttributeSource]: aaa
[TransactionInterceptor]: aaa
[BeanFactoryTransactionAttributeSourceAdvisor]: aaa
[Advisor]: aaa
[AbstractAdvisorAutoProxyCreator]: aaa
[Pointcut]: aaa
[StaticMethodMatcherPointcut]: aaa
[StaticMethodMatcher]: aaa
[TransactionAttributeSource]: aaa
[TransactionAttribute]: aaa
[RuleBasedTransactionAttribute]: aaa