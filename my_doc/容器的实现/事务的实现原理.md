首先看一个事务回滚的测试用例：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	   xmlns:tx="http://www.springframework.org/schema/tx"
	   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd

       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd">

	<tx:annotation-driven/>

	<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource"/>
	</bean>

	<bean id="bookDao" class="org.springframework.transaction.annotation.dhf.book.dao.impl.JdbcTemplateBookDao">
		<property name="dataSource" ref="dataSource"/>
	</bean>

</beans>
```

```java
public class MyAnnotationTransactionTests {
	ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("org/springframework/transaction/annotation/dhf/MyAnnotationTransactionTests.xml");
	@Test
	public void baseTest() {
		BookDao bookDao = (BookDao) context.getBean("bookDao");
		System.out.println(bookDao.getAll());
	}

	@Test
	public void requestTest() {
		BookDao bookDao = (BookDao) context.getBean("bookDao");
		int count = bookDao.getAll().size();
		System.out.println("count: " + count);

		try {
			System.out.println("insertWithException");
			bookDao.insertWithException(new Book() {{
				setName("test");
				setYear(1);
			}});
		} catch (Exception e) {
			System.out.println(e.getMessage());;
		}

		count = bookDao.getAll().size();
		System.out.println("count: " + count);

		try {
			System.out.println("insert");
			bookDao.insert(new Book() {{
				setName("test");
				setYear(1);
			}});
		} catch (Exception e) {
			e.printStackTrace();
		}

		count = bookDao.getAll().size();
		System.out.println("count: " + count);
	}
}

/*
输出：
count: 5
insertWithException
test insert exception
count: 5
insert
count: 6
*/
```

上面用到的[BookDao]接口及用到的`insert()`和`insertWithException()`方法代码：
```java
@Transactional(propagation = Propagation.REQUIRED)
public interface BookDao {
    void insert(Book book);

    void insertWithException(Book book);

    void insertBatch(List<Book> books);

    void delete(Book book);

    void deleteAll();

    Book getById(Integer id);

    List<Book> getAll();
}

@Override
public void insert(Book book) {
    String sql = "INSERT INTO BOOK(BOOK_ID, NAME, YEAR) VALUES (?, ?, ?)";

    getJdbcTemplate().update(sql, new Object[]{book.getBookId(), book.getName(), book.getYear()});
}
@Override
public void insertWithException(Book book) {
    String sql = "INSERT INTO BOOK(BOOK_ID, NAME, YEAR) VALUES (?, ?, ?)";

    getJdbcTemplate().update(sql, new Object[]{book.getBookId(), book.getName(), book.getYear()});
    throw new RuntimeException("test insert exception");
}
```

可以看到，当insert后抛出异常，数据不会被插入到数据库，即数据库回滚了，而正常执行的insert成功插入了，下面分析Spring中事务的实现原理，首先和AOP一样，先找到XML中`tx`对应的[NamespaceHandler]，其实现是[TxNamespaceHandler]，代码：
```java
public class TxNamespaceHandler extends NamespaceHandlerSupport {

	static final String TRANSACTION_MANAGER_ATTRIBUTE = "transaction-manager";

	// 默认事务管理器的bean name
  static final String DEFAULT_TRANSACTION_MANAGER_BEAN_NAME = "transactionManager";


	static String getTransactionManagerName(Element element) {
		return (element.hasAttribute(TRANSACTION_MANAGER_ATTRIBUTE) ?
				element.getAttribute(TRANSACTION_MANAGER_ATTRIBUTE) : DEFAULT_TRANSACTION_MANAGER_BEAN_NAME);
	}


	@Override
	public void init() {
		registerBeanDefinitionParser("advice", new TxAdviceBeanDefinitionParser());
		registerBeanDefinitionParser("annotation-driven", new AnnotationDrivenBeanDefinitionParser());
		registerBeanDefinitionParser("jta-transaction-manager", new JtaTransactionManagerBeanDefinitionParser());
	}

}
```

`annotation-driven`对应的解析类是[AnnotationDrivenBeanDefinitionParser]，代码：
```java
class AnnotationDrivenBeanDefinitionParser implements BeanDefinitionParser {
	@Override
	@Nullable
	public BeanDefinition parse(Element element, ParserContext parserContext) {
		registerTransactionalEventListenerFactory(parserContext);
		String mode = element.getAttribute("mode");
		if ("aspectj".equals(mode)) {
			// 如果设置mode为aspectj则使用aspectj创建代理
			// mode="aspectj"
			registerTransactionAspect(element, parserContext);
		}
		else {
			// mode="proxy"
			AopAutoProxyConfigurer.configureAutoProxyCreator(element, parserContext);
		}
		return null;
	}

	private void registerTransactionAspect(Element element, ParserContext parserContext) {
		String txAspectBeanName = TransactionManagementConfigUtils.TRANSACTION_ASPECT_BEAN_NAME;
		String txAspectClassName = TransactionManagementConfigUtils.TRANSACTION_ASPECT_CLASS_NAME;
		if (!parserContext.getRegistry().containsBeanDefinition(txAspectBeanName)) {
			RootBeanDefinition def = new RootBeanDefinition();
			def.setBeanClassName(txAspectClassName);
			def.setFactoryMethodName("aspectOf");
			registerTransactionManager(element, def);
			parserContext.registerBeanComponent(new BeanComponentDefinition(def, txAspectBeanName));
		}
	}

	private static void registerTransactionManager(Element element, BeanDefinition def) {
		def.getPropertyValues().add("transactionManagerBeanName",
				TxNamespaceHandler.getTransactionManagerName(element));
	}

	private void registerTransactionalEventListenerFactory(ParserContext parserContext) {
		RootBeanDefinition def = new RootBeanDefinition();
		def.setBeanClass(TransactionalEventListenerFactory.class);
		parserContext.registerBeanComponent(new BeanComponentDefinition(def,
				TransactionManagementConfigUtils.TRANSACTIONAL_EVENT_LISTENER_FACTORY_BEAN_NAME));
	}

	private static class AopAutoProxyConfigurer {
		public static void configureAutoProxyCreator(Element element, ParserContext parserContext) {
			// 事务的实现是基于aop的，这里添加InfrastructureAdvisorAutoProxyCreator的BeanDefinition到BeanFactory，InfrastructureAdvisorAutoProxyCreator
			// 能够将role为ROLE_INFRASTRUCTURE并且实现了Advisor接口的bean添加到aop的可用advisor列表中
			AopNamespaceUtils.registerAutoProxyCreatorIfNecessary(parserContext, element);

			String txAdvisorBeanName = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME;
			if (!parserContext.getRegistry().containsBeanDefinition(txAdvisorBeanName)) {
				Object eleSource = parserContext.extractSource(element);

				// Create the TransactionAttributeSource definition.
				// 注册class为AnnotationTransactionAttributeSource的bean
				RootBeanDefinition sourceDef = new RootBeanDefinition(
						"org.springframework.transaction.annotation.AnnotationTransactionAttributeSource");
				sourceDef.setSource(eleSource);
				sourceDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
				// 注册BeanDefinition到BeanFactory，用DefaultBeanNameGenerator生成bean name，默认为className#0
				String sourceName = parserContext.getReaderContext().registerWithGeneratedName(sourceDef);

				// Create the TransactionInterceptor definition.
				// 注册class为TransactionInterceptor的bean
				RootBeanDefinition interceptorDef = new RootBeanDefinition(TransactionInterceptor.class);
				interceptorDef.setSource(eleSource);
				interceptorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
				// 将<tx:annotation-driven/>中的transaction-manager属性添加到该bean的PropertyValues中，如果没有则默认为transactionManager
				registerTransactionManager(element, interceptorDef);
				// 添加transactionAttributeSource属性为上面注册的AnnotationTransactionAttributeSource的引用
				interceptorDef.getPropertyValues().add("transactionAttributeSource", new RuntimeBeanReference(sourceName));
				String interceptorName = parserContext.getReaderContext().registerWithGeneratedName(interceptorDef);

				// Create the TransactionAttributeSourceAdvisor definition.
				// 注册class为BeanFactoryTransactionAttributeSourceAdvisor的bean，BeanFactoryTransactionAttributeSourceAdvisor实现了Advisor接口
				RootBeanDefinition advisorDef = new RootBeanDefinition(BeanFactoryTransactionAttributeSourceAdvisor.class);
				advisorDef.setSource(eleSource);
				advisorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
				// 添加上面注册的两个bean到下面两个属性中
				advisorDef.getPropertyValues().add("transactionAttributeSource", new RuntimeBeanReference(sourceName));
				advisorDef.getPropertyValues().add("adviceBeanName", interceptorName);
				if (element.hasAttribute("order")) {
					advisorDef.getPropertyValues().add("order", element.getAttribute("order"));
				}
				// 注册BeanDefinition
				parserContext.getRegistry().registerBeanDefinition(txAdvisorBeanName, advisorDef);

				// 发起上面3个BeanDefinition的注册事件
				CompositeComponentDefinition compositeDef = new CompositeComponentDefinition(element.getTagName(), eleSource);
				compositeDef.addNestedComponent(new BeanComponentDefinition(sourceDef, sourceName));
				compositeDef.addNestedComponent(new BeanComponentDefinition(interceptorDef, interceptorName));
				compositeDef.addNestedComponent(new BeanComponentDefinition(advisorDef, txAdvisorBeanName));
				parserContext.registerComponent(compositeDef);
			}
		}
	}

}
```

[AnnotationDrivenBeanDefinitionParser]一共注册了4个[BeanDefinition]，其中[AnnotationTransactionAttributeSource]和[TransactionInterceptor]都被设置为[BeanFactoryTransactionAttributeSourceAdvisor]的属性，所以先从[BeanFactoryTransactionAttributeSourceAdvisor]的代码入手，下面是[BeanFactoryTransactionAttributeSourceAdvisor]的继承结构：
![BeanFactoryTransactionAttributeSourceAdvisor继承结构](../img/BeanFactoryTransactionAttributeSourceAdvisor.png)

[BeanFactoryTransactionAttributeSourceAdvisor]实现了[Advisor]接口，[AnnotationDrivenBeanDefinitionParser]中注册的[InfrastructureAdvisorAutoProxyCreator]会在创建bean时获取所有实现了[Advisor]接口的Bean以创建其他Bean的代理，所以创建普通Bean时[BeanFactoryTransactionAttributeSourceAdvisor]会被作为[Advisor]参与Bean的代理创建过程，[BeanFactoryTransactionAttributeSourceAdvisor]作为[Advisor]时涉及到的方法有：
```java
private final TransactionAttributeSourcePointcut pointcut = new TransactionAttributeSourcePointcut() {
  @Override
  @Nullable
  protected TransactionAttributeSource getTransactionAttributeSource() {
    return transactionAttributeSource;
  }
};

@Override
public Pointcut getPointcut() {
  return this.pointcut;
}

@Override
public Advice getAdvice() {
  Advice advice = this.advice;
  if (advice != null) {
    return advice;
  }

  // 如果Advice还未初始化则根据adviceBeanName获取Advice
  Assert.state(this.adviceBeanName != null, "'adviceBeanName' must be specified");
  Assert.state(this.beanFactory != null, "BeanFactory must be set to resolve 'adviceBeanName'");

  if (this.beanFactory.isSingleton(this.adviceBeanName)) {
    // Rely on singleton semantics provided by the factory.
    advice = this.beanFactory.getBean(this.adviceBeanName, Advice.class);
    this.advice = advice;
    return advice;
  }
  else {
    // No singleton guarantees from the factory -> let's lock locally but
    // reuse the factory's singleton lock, just in case a lazy dependency
    // of our advice bean happens to trigger the singleton lock implicitly...
    synchronized (this.adviceMonitor) {
      advice = this.advice;
      if (advice == null) {
        advice = this.beanFactory.getBean(this.adviceBeanName, Advice.class);
        this.advice = advice;
      }
      return advice;
    }
  }
}
```

其中`adviceBeanName`属性就是[AnnotationDrivenBeanDefinitionParser]中注册的[TransactionInterceptor]的bean name，从笔记[如何实现AOP](如何实现AOP.md)可知，创建Bean代理之前，[AbstractAdvisorAutoProxyCreator]类的`findEligibleAdvisors()`方法会遍历所有的[Advisor]并过滤掉不匹配正在创建的Bean的[Advisor]，过滤过程会根据[Advisor]的类型执行不同的逻辑，对于[BeanFactoryTransactionAttributeSourceAdvisor]类，其实现了[PointcutAdvisor]接口，所以过滤时会调用[BeanFactoryTransactionAttributeSourceAdvisor]的`getPointcut()`方法获取[Pointcut]并通过[Pointcut]类判断[Advisor]的适用性，而[BeanFactoryTransactionAttributeSourceAdvisor]的[Pointcut]就是匿名的[TransactionAttributeSourcePointcut]实现类，实现`getTransactionAttributeSource()`方法返回[BeanFactoryTransactionAttributeSourceAdvisor]中的`transactionAttributeSource`属性，也就是[AnnotationDrivenBeanDefinitionParser]中注册的[AnnotationTransactionAttributeSource]，下面先看[TransactionAttributeSourcePointcut]的实现，下面是[TransactionAttributeSourcePointcut]的继承结构：
![TransactionAttributeSourcePointcut的继承结构](../img/TransactionAttributeSourcePointcut.png)

[StaticMethodMatcher]定义了一个静态的[MethodMatcher]的基本实现，即匹配结果不受方法参数的影响，代码：
```java
public abstract class StaticMethodMatcher implements MethodMatcher {

	@Override
	public final boolean isRuntime() {
		// 表示当前MethodMatcher
		return false;
	}

	@Override
	public final boolean matches(Method method, @Nullable Class<?> targetClass, Object... args) {
		// should never be invoked because isRuntime() returns false
		throw new UnsupportedOperationException("Illegal MethodMatcher usage");
	}

}
```

[StaticMethodMatcherPointcut]类实现了基本的get、set方法
```java
public abstract class StaticMethodMatcherPointcut extends StaticMethodMatcher implements Pointcut {

	private ClassFilter classFilter = ClassFilter.TRUE;

	public void setClassFilter(ClassFilter classFilter) {
		this.classFilter = classFilter;
	}

	@Override
	public ClassFilter getClassFilter() {
		return this.classFilter;
	}


	@Override
	public final MethodMatcher getMethodMatcher() {
		// StaticMethodMatcherPointcut类实现了MethodMatcher接口，所以这里直接把自己作为MethodMatcher返回
		return this;
	}

}
```

下面是[TransactionAttributeSourcePointcut]的代码：
```java
@SuppressWarnings("serial")
abstract class TransactionAttributeSourcePointcut extends StaticMethodMatcherPointcut implements Serializable {

	@Override
	public boolean matches(Method method, @Nullable Class<?> targetClass) {
		// 如果bean本身是个代理，则不匹配
		if (targetClass != null && TransactionalProxy.class.isAssignableFrom(targetClass)) {
			return false;
		}
		// 返回的实际上就是AnnotationTransactionAttributeSource
		TransactionAttributeSource tas = getTransactionAttributeSource();
		// 如果AnnotationTransactionAttributeSource能够从方法中获取到TransactionAttribute实例则表示该方法需要被代理，即匹配成功
		return (tas == null || tas.getTransactionAttribute(method, targetClass) != null);
	}

	@Override
	public boolean equals(Object other) {
		if (this == other) {
			return true;
		}
		if (!(other instanceof TransactionAttributeSourcePointcut)) {
			return false;
		}
		TransactionAttributeSourcePointcut otherPc = (TransactionAttributeSourcePointcut) other;
		return ObjectUtils.nullSafeEquals(getTransactionAttributeSource(), otherPc.getTransactionAttributeSource());
	}

	@Override
	public int hashCode() {
		return TransactionAttributeSourcePointcut.class.hashCode();
	}

	@Override
	public String toString() {
		return getClass().getName() + ": " + getTransactionAttributeSource();
	}

	@Nullable
	protected abstract TransactionAttributeSource getTransactionAttributeSource();

}
```

所以下面需要看[AnnotationTransactionAttributeSource]的实现，下面是[AnnotationTransactionAttributeSource]的继承结构：
![AnnotationTransactionAttributeSource的继承结构](../img/AnnotationTransactionAttributeSource.png)

[TransactionAttributeSource]接口代码：
```java
public interface TransactionAttributeSource {
	@Nullable
	TransactionAttribute getTransactionAttribute(Method method, @Nullable Class<?> targetClass);
}
```

[TransactionAttribute]的作用是返回方法上的事务属性，代码：
```java
public interface TransactionAttribute extends TransactionDefinition {
	@Nullable
	// 返回事务的qualifier值，即Transactional注解的transactionManager属性值，用于选择事务对应的transactionManager
	String getQualifier();

	// 判断传入的异常是否需要回滚
	boolean rollbackOn(Throwable ex);
}
```

[AbstractFallbackTransactionAttributeSource]抽象类实现了获取[TransactionAttribute]的基本逻辑，具体获取[TransactionAttribute]的实现由子类实现，代码：
```java
public abstract class AbstractFallbackTransactionAttributeSource implements TransactionAttributeSource {
	private static final TransactionAttribute NULL_TRANSACTION_ATTRIBUTE = new DefaultTransactionAttribute();

	protected final Log logger = LogFactory.getLog(getClass());

	// TransactionAttribute的缓存，key为执行方法和方法所在类组成的对象
	private final Map<Object, TransactionAttribute> attributeCache = new ConcurrentHashMap<>(1024);

	@Override
	@Nullable
	public TransactionAttribute getTransactionAttribute(Method method, @Nullable Class<?> targetClass) {
		if (method.getDeclaringClass() == Object.class) {
			return null;
		}

		// First, see if we have a cached value.
		Object cacheKey = getCacheKey(method, targetClass);
		Object cached = this.attributeCache.get(cacheKey);
		// 先尝试从缓存中获取
		if (cached != null) {
			// Value will either be canonical value indicating there is no transaction attribute,
			// or an actual transaction attribute.
			// 如果缓存中保存的是NULL_TRANSACTION_ATTRIBUTE则说明之前判断过了该方法不需要事务
			if (cached == NULL_TRANSACTION_ATTRIBUTE) {
				return null;
			}
			else {
				return (TransactionAttribute) cached;
			}
		}
		else {
			// We need to work it out.
			// 创建TransactionAttribute
			TransactionAttribute txAttr = computeTransactionAttribute(method, targetClass);
			// Put it in the cache.
			if (txAttr == null) {
				// 如果txAttr为空，则保存NULL_TRANSACTION_ATTRIBUTE到缓存，下次在获取时直接返回null
				this.attributeCache.put(cacheKey, NULL_TRANSACTION_ATTRIBUTE);
			}
			else {
				// 获取方法的唯一名称，由全类名.方法名组成
				String methodIdentification = ClassUtils.getQualifiedMethodName(method, targetClass);
				if (txAttr instanceof DefaultTransactionAttribute) {
					((DefaultTransactionAttribute) txAttr).setDescriptor(methodIdentification);
				}
				if (logger.isDebugEnabled()) {
					logger.debug("Adding transactional method '" + methodIdentification + "' with attribute: " + txAttr);
				}
				// 结果保存到缓存中
				this.attributeCache.put(cacheKey, txAttr);
			}
			return txAttr;
		}
	}

	protected Object getCacheKey(Method method, @Nullable Class<?> targetClass) {
		return new MethodClassKey(method, targetClass);
	}

	@Nullable
	protected TransactionAttribute computeTransactionAttribute(Method method, @Nullable Class<?> targetClass) {
		// Don't allow no-public methods as required.
		// 默认情况下非public的方法不执行事务
		if (allowPublicMethodsOnly() && !Modifier.isPublic(method.getModifiers())) {
			return null;
		}

		// The method may be on an interface, but we need attributes from the target class.
		// If the target class is null, the method will be unchanged.
		// 如果method的声明类不是specificTargetClass，则从specificTargetClass开始获取实现了method方法的类并返回该方法，即
		// 获取最具体的方法实现
		Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);

		// First try is the method in the target class.
		// 供子类实现，获取方法上的TransactionAttribute属性，如果返回值不为空则直接返回
		TransactionAttribute txAttr = findTransactionAttribute(specificMethod);
		if (txAttr != null) {
			return txAttr;
		}

		// Second try is the transaction attribute on the target class.
		txAttr = findTransactionAttribute(specificMethod.getDeclaringClass());
		// 供子类实现，获取类上的TransactionAttribute属性，如果返回值不为空并且方法是用户创建的而不是桥接方法等自动生成的方法，则直接返回
		if (txAttr != null && ClassUtils.isUserLevelMethod(method)) {
			return txAttr;
		}

		// 如果没从子类获取到TransactionAttribute，则再使用原始的方法获取一次
		if (specificMethod != method) {
			// Fallback is to look at the original method.
			txAttr = findTransactionAttribute(method);
			if (txAttr != null) {
				return txAttr;
			}
			// Last fallback is the class of the original method.
			txAttr = findTransactionAttribute(method.getDeclaringClass());
			if (txAttr != null && ClassUtils.isUserLevelMethod(method)) {
				return txAttr;
			}
		}

		return null;
	}

	@Nullable
	protected abstract TransactionAttribute findTransactionAttribute(Method method);

	@Nullable
	protected abstract TransactionAttribute findTransactionAttribute(Class<?> clazz);

	// 是否只有public方法才能执行事务
	protected boolean allowPublicMethodsOnly() {
		return false;
	}

}
```

最后是[AnnotationTransactionAttributeSource]的实现，代码：
```java
@SuppressWarnings("serial")
public class AnnotationTransactionAttributeSource extends AbstractFallbackTransactionAttributeSource
		implements Serializable {

	// 判断是否使用了javax.transaction.Transactional注解，如果是则在获取TransactionAttributeSource时需要使用相应的解析类获取
	private static final boolean jta12Present = ClassUtils.isPresent(
			"javax.transaction.Transactional", AnnotationTransactionAttributeSource.class.getClassLoader());

	// 同上
	private static final boolean ejb3Present = ClassUtils.isPresent(
			"javax.ejb.TransactionAttribute", AnnotationTransactionAttributeSource.class.getClassLoader());

	private final boolean publicMethodsOnly;

	// TransactionAnnotationParser根据注解获取TransactionAttributeSource
	private final Set<TransactionAnnotationParser> annotationParsers;

	public AnnotationTransactionAttributeSource() {
		this(true);
	}

	public AnnotationTransactionAttributeSource(boolean publicMethodsOnly) {
		this.publicMethodsOnly = publicMethodsOnly;
		this.annotationParsers = new LinkedHashSet<>(2);
		// Spring的Transactional注解的解析类
		this.annotationParsers.add(new SpringTransactionAnnotationParser());
		// javax.transaction.Transactional注解的解析类
		if (jta12Present) {
			this.annotationParsers.add(new JtaTransactionAnnotationParser());
		}
		// javax.ejb.TransactionAttribute注解的解析类
		if (ejb3Present) {
			this.annotationParsers.add(new Ejb3TransactionAnnotationParser());
		}
	}
	
	public AnnotationTransactionAttributeSource(TransactionAnnotationParser annotationParser) {
		this.publicMethodsOnly = true;
		Assert.notNull(annotationParser, "TransactionAnnotationParser must not be null");
		this.annotationParsers = Collections.singleton(annotationParser);
	}
	
	public AnnotationTransactionAttributeSource(TransactionAnnotationParser... annotationParsers) {
		this.publicMethodsOnly = true;
		Assert.notEmpty(annotationParsers, "At least one TransactionAnnotationParser needs to be specified");
		Set<TransactionAnnotationParser> parsers = new LinkedHashSet<>(annotationParsers.length);
		Collections.addAll(parsers, annotationParsers);
		this.annotationParsers = parsers;
	}

	public AnnotationTransactionAttributeSource(Set<TransactionAnnotationParser> annotationParsers) {
		this.publicMethodsOnly = true;
		Assert.notEmpty(annotationParsers, "At least one TransactionAnnotationParser needs to be specified");
		this.annotationParsers = annotationParsers;
	}


	@Override
	@Nullable
	protected TransactionAttribute findTransactionAttribute(Method method) {
		return determineTransactionAttribute(method);
	}

	@Override
	@Nullable
	protected TransactionAttribute findTransactionAttribute(Class<?> clazz) {
		return determineTransactionAttribute(clazz);
	}

	@Nullable
	protected TransactionAttribute determineTransactionAttribute(AnnotatedElement ae) {
		for (TransactionAnnotationParser annotationParser : this.annotationParsers) {
			TransactionAttribute attr = annotationParser.parseTransactionAnnotation(ae);
			if (attr != null) {
				return attr;
			}
		}
		return null;
	}

	@Override
	protected boolean allowPublicMethodsOnly() {
		return this.publicMethodsOnly;
	}


	@Override
	public boolean equals(Object other) {
		if (this == other) {
			return true;
		}
		if (!(other instanceof AnnotationTransactionAttributeSource)) {
			return false;
		}
		AnnotationTransactionAttributeSource otherTas = (AnnotationTransactionAttributeSource) other;
		return (this.annotationParsers.equals(otherTas.annotationParsers) &&
				this.publicMethodsOnly == otherTas.publicMethodsOnly);
	}

	@Override
	public int hashCode() {
		return this.annotationParsers.hashCode();
	}

}
```

[AnnotationTransactionAttributeSource]内部定义了多个[TransactionAnnotationParser]的实现，获取[TransactionAttribute]实际上就是这些[TransactionAnnotationParser]的实现的，以Spring的[Transactional]注解为例，实现是[SpringTransactionAnnotationParser]类，[SpringTransactionAnnotationParser]解析注解属性并将这些属性保存到[RuleBasedTransactionAttribute]实例中并返回，代码：
```java
@SuppressWarnings("serial")
public class SpringTransactionAnnotationParser implements TransactionAnnotationParser, Serializable {

	@Override
	@Nullable
	public TransactionAttribute parseTransactionAnnotation(AnnotatedElement ae) {
		// 合并注解的属性，方法上的Transactional注解属性会覆盖类上的属性
		AnnotationAttributes attributes = AnnotatedElementUtils.findMergedAnnotationAttributes(
				ae, Transactional.class, false, false);
		if (attributes != null) {
			return parseTransactionAnnotation(attributes);
		}
		else {
			return null;
		}
	}

	public TransactionAttribute parseTransactionAnnotation(Transactional ann) {
		return parseTransactionAnnotation(AnnotationUtils.getAnnotationAttributes(ann, false, false));
	}

	protected TransactionAttribute parseTransactionAnnotation(AnnotationAttributes attributes) {
		// 创建RuleBasedTransactionAttribute类，并为RuleBasedTransactionAttribute设置传入的注解的若干属性值
		RuleBasedTransactionAttribute rbta = new RuleBasedTransactionAttribute();
		Propagation propagation = attributes.getEnum("propagation");
		rbta.setPropagationBehavior(propagation.value());
		Isolation isolation = attributes.getEnum("isolation");
		rbta.setIsolationLevel(isolation.value());
		rbta.setTimeout(attributes.getNumber("timeout").intValue());
		rbta.setReadOnly(attributes.getBoolean("readOnly"));
		rbta.setQualifier(attributes.getString("value"));
		ArrayList<RollbackRuleAttribute> rollBackRules = new ArrayList<>();
		Class<?>[] rbf = attributes.getClassArray("rollbackFor");
		for (Class<?> rbRule : rbf) {
			// rbf表示所有应该被回滚的异常，这里用RollbackRuleAttribute封装异常类并保存到RuleBasedTransactionAttribute中
			RollbackRuleAttribute rule = new RollbackRuleAttribute(rbRule);
			rollBackRules.add(rule);
		}
		String[] rbfc = attributes.getStringArray("rollbackForClassName");
		for (String rbRule : rbfc) {
			// 同上
			RollbackRuleAttribute rule = new RollbackRuleAttribute(rbRule);
			rollBackRules.add(rule);
		}
		Class<?>[] nrbf = attributes.getClassArray("noRollbackFor");
		for (Class<?> rbRule : nrbf) {
			// nrbf表示所有不应该被回滚的异常
			NoRollbackRuleAttribute rule = new NoRollbackRuleAttribute(rbRule);
			rollBackRules.add(rule);
		}
		String[] nrbfc = attributes.getStringArray("noRollbackForClassName");
		for (String rbRule : nrbfc) {
			// 同上
			NoRollbackRuleAttribute rule = new NoRollbackRuleAttribute(rbRule);
			rollBackRules.add(rule);
		}
		rbta.getRollbackRules().addAll(rollBackRules);
		return rbta;
	}

	@Override
	public boolean equals(Object other) {
		return (this == other || other instanceof SpringTransactionAnnotationParser);
	}

	@Override
	public int hashCode() {
		return SpringTransactionAnnotationParser.class.hashCode();
	}

}
```

以上是针对[BeanFactoryTransactionAttributeSourceAdvisor]实现的`getPointcut()`方法，对于[Pointcut]，只是Spring中AOP的验证，而代理的实现则是[Advice]，[BeanFactoryTransactionAttributeSourceAdvisor]返回的[Advice]是[TransactionInterceptor]，下面在分析[TransactionInterceptor]的实现，下面是[TransactionInterceptor]的继承结构：
![TransactionInterceptor继承结构](../img/TransactionInterceptor.png)

如果看过笔记[从容器获取Bean](从容器获取Bean.md)和[如何实现AOP](如何实现AOP.md)，那对上面的接口不会默认，所以下面直接看实现类，首先是[TransactionAspectSupport]，该类实现了事务代理执行过程中的所有逻辑，代码：
```java
public abstract class TransactionAspectSupport implements BeanFactoryAware, InitializingBean {
	private static final Object DEFAULT_TRANSACTION_MANAGER_KEY = new Object();

	// TransactionInfo保存了事务相关的所有信息，包括transactionManager、transactionAttribute、事务状态等
	private static final ThreadLocal<TransactionInfo> transactionInfoHolder =
			new NamedThreadLocal<>("Current aspect-driven transaction");

	@Nullable
	protected static TransactionInfo currentTransactionInfo() throws NoTransactionException {
		return transactionInfoHolder.get();
	}

	public static TransactionStatus currentTransactionStatus() throws NoTransactionException {
		TransactionInfo info = currentTransactionInfo();
		if (info == null || info.transactionStatus == null) {
			throw new NoTransactionException("No transaction aspect-managed TransactionStatus in scope");
		}
		return info.transactionStatus;
	}


	protected final Log logger = LogFactory.getLog(getClass());

	@Nullable
	// AnnotationDrivenBeanDefinitionParser中默认设置该属性为transactionManager
	private String transactionManagerBeanName;

	@Nullable
	private PlatformTransactionManager transactionManager;

	@Nullable
	// transactionAttributeSource实际上就是AnnotationDrivenBeanDefinitionParser中注册的AnnotationTransactionAttributeSource
	private TransactionAttributeSource transactionAttributeSource;

	@Nullable
	private BeanFactory beanFactory;

	// PlatformTransactionManager的缓存，key为qualifier
	private final ConcurrentMap<Object, PlatformTransactionManager> transactionManagerCache =
			new ConcurrentReferenceHashMap<>(4);

	public void setTransactionManagerBeanName(@Nullable String transactionManagerBeanName) {
		this.transactionManagerBeanName = transactionManagerBeanName;
	}

	@Nullable
	protected final String getTransactionManagerBeanName() {
		return this.transactionManagerBeanName;
	}
	
	public void setTransactionManager(@Nullable PlatformTransactionManager transactionManager) {
		this.transactionManager = transactionManager;
	}
	
	@Nullable
	public PlatformTransactionManager getTransactionManager() {
		return this.transactionManager;
	}

	public void setTransactionAttributes(Properties transactionAttributes) {
		NameMatchTransactionAttributeSource tas = new NameMatchTransactionAttributeSource();
		tas.setProperties(transactionAttributes);
		this.transactionAttributeSource = tas;
	}

	public void setTransactionAttributeSources(TransactionAttributeSource... transactionAttributeSources) {
		this.transactionAttributeSource = new CompositeTransactionAttributeSource(transactionAttributeSources);
	}

	public void setTransactionAttributeSource(@Nullable TransactionAttributeSource transactionAttributeSource) {
		this.transactionAttributeSource = transactionAttributeSource;
	}

	@Nullable
	public TransactionAttributeSource getTransactionAttributeSource() {
		return this.transactionAttributeSource;
	}

	@Override
	public void setBeanFactory(@Nullable BeanFactory beanFactory) {
		this.beanFactory = beanFactory;
	}

	@Nullable
	protected final BeanFactory getBeanFactory() {
		return this.beanFactory;
	}

	@Override
	public void afterPropertiesSet() {
		// 检查transactionManager、beanFactory和transactionAttributeSource是否为空
		if (getTransactionManager() == null && this.beanFactory == null) {
			throw new IllegalStateException(
					"Set the 'transactionManager' property or make sure to run within a BeanFactory " +
					"containing a PlatformTransactionManager bean!");
		}
		if (getTransactionAttributeSource() == null) {
			throw new IllegalStateException(
					"Either 'transactionAttributeSource' or 'transactionAttributes' is required: " +
					"If there are no transactional methods, then don't use a transaction aspect.");
		}
	}

	@Nullable
	// 方法执行事务时实际上执行的是该方法，参数invocation的默认实现是调用MethodInvocation的proceed方法
	protected Object invokeWithinTransaction(Method method, @Nullable Class<?> targetClass,
			final InvocationCallback invocation) throws Throwable {

		// If the transaction attribute is null, the method is non-transactional.
		// 这里返回的实际上是AnnotationTransactionAttributeSource
		TransactionAttributeSource tas = getTransactionAttributeSource();
		// 对于使用默认的Spring的Transaction注解的方法，AnnotationTransactionAttributeSource返回的TransactionAttribute实例是RuleBasedTransactionAttribute
		final TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null);
		final PlatformTransactionManager tm = determineTransactionManager(txAttr);
		// 以方法的唯一标识表示当前的连接点
		final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);

		// CallbackPreferringPlatformTransactionManager在PlatformTransactionManager接口的基础上定义了一个execute方法，用于代替PlatformTransactionManager
		// 执行事务管理逻辑
		if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) {
			// Standard transaction demarcation with getTransaction and commit/rollback calls.
			// 如果txAttr不为空，则开启事务，创建TransactionInfo对象并保存事务状态到TransactionInfo对象中
			TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);
			Object retVal = null;
			try {
				// This is an around advice: Invoke the next interceptor in the chain.
				// This will normally result in a target object being invoked.
				// 执行MethodInvocation的proceed方法，即执行其他Advice，如果没有Advice则是执行被代理方法
				retVal = invocation.proceedWithInvocation();
			}
			catch (Throwable ex) {
				// target invocation exception
				// 如果发生异常，则根据保存在txInfo中的transactionAttribute判断是否需要回滚，如果需要则调用txInfo中的transactionManager的rollback方法
				// 如果不需要回滚则执行txInfo中的transactionManager的commit方法
				completeTransactionAfterThrowing(txInfo, ex);
				throw ex;
			}
			finally {
				// Spring的事务是可嵌套的，这里将事务还原成外部事务
				cleanupTransactionInfo(txInfo);
			}
			// 执行txInfo中的transactionManager的commit方法
			commitTransactionAfterReturning(txInfo);
			return retVal;
		}

		else {
			final ThrowableHolder throwableHolder = new ThrowableHolder();

			// It's a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.
			try {
				Object result = ((CallbackPreferringPlatformTransactionManager) tm).execute(txAttr, status -> {
					// 创建TransactionInfo
					TransactionInfo txInfo = prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);
					try {
						return invocation.proceedWithInvocation();
					}
					catch (Throwable ex) {
						// 发生异常时判断是否需要回滚
						if (txAttr.rollbackOn(ex)) {
							// A RuntimeException: will lead to a rollback.
							if (ex instanceof RuntimeException) {
								throw (RuntimeException) ex;
							}
							else {
								throw new ThrowableHolderException(ex);
							}
						}
						else {
							// A normal return value: will lead to a commit.
							throwableHolder.throwable = ex;
							return null;
						}
					}
					finally {
						cleanupTransactionInfo(txInfo);
					}
				});

				// Check result state: It might indicate a Throwable to rethrow.
				if (throwableHolder.throwable != null) {
					throw throwableHolder.throwable;
				}
				return result;
			}
			catch (ThrowableHolderException ex) {
				throw ex.getCause();
			}
			catch (TransactionSystemException ex2) {
				if (throwableHolder.throwable != null) {
					logger.error("Application exception overridden by commit exception", throwableHolder.throwable);
					ex2.initApplicationException(throwableHolder.throwable);
				}
				throw ex2;
			}
			catch (Throwable ex2) {
				if (throwableHolder.throwable != null) {
					logger.error("Application exception overridden by commit exception", throwableHolder.throwable);
				}
				throw ex2;
			}
		}
	}

	protected void clearTransactionManagerCache() {
		this.transactionManagerCache.clear();
		this.beanFactory = null;
	}

	@Nullable
	// 根据transactionManagerBeanName或txAttr中的qualifier获取PlatformTransactionManager
	protected PlatformTransactionManager determineTransactionManager(@Nullable TransactionAttribute txAttr) {
		// Do not attempt to lookup tx manager if no tx attributes are set
		if (txAttr == null || this.beanFactory == null) {
			return getTransactionManager();
		}

		String qualifier = txAttr.getQualifier();
		// 根据qualifier的值获取transactionManager，实际上就是根据qualifier从beanFactory获取bean
		if (StringUtils.hasText(qualifier)) {
			return determineQualifiedTransactionManager(this.beanFactory, qualifier);
		}
		// 默认被设置为transactionManager
		else if (StringUtils.hasText(this.transactionManagerBeanName)) {
			return determineQualifiedTransactionManager(this.beanFactory, this.transactionManagerBeanName);
		}
		else {
			// 如果没有设置默认的PlatformTransactionManager，则从bean中获取实现了PlatformTransactionManager接口的bean
			PlatformTransactionManager defaultTransactionManager = getTransactionManager();
			if (defaultTransactionManager == null) {
				defaultTransactionManager = this.transactionManagerCache.get(DEFAULT_TRANSACTION_MANAGER_KEY);
				if (defaultTransactionManager == null) {
					defaultTransactionManager = this.beanFactory.getBean(PlatformTransactionManager.class);
					this.transactionManagerCache.putIfAbsent(
							DEFAULT_TRANSACTION_MANAGER_KEY, defaultTransactionManager);
				}
			}
			return defaultTransactionManager;
		}
	}

	private PlatformTransactionManager determineQualifiedTransactionManager(BeanFactory beanFactory, String qualifier) {
		PlatformTransactionManager txManager = this.transactionManagerCache.get(qualifier);
		if (txManager == null) {
			txManager = BeanFactoryAnnotationUtils.qualifiedBeanOfType(
					beanFactory, PlatformTransactionManager.class, qualifier);
			this.transactionManagerCache.putIfAbsent(qualifier, txManager);
		}
		return txManager;
	}

	// 获取方法的唯一标识，默认为方法所在类的全类名.方法名
	private String methodIdentification(Method method, @Nullable Class<?> targetClass,
			@Nullable TransactionAttribute txAttr) {

		String methodIdentification = methodIdentification(method, targetClass);
		if (methodIdentification == null) {
			if (txAttr instanceof DefaultTransactionAttribute) {
				methodIdentification = ((DefaultTransactionAttribute) txAttr).getDescriptor();
			}
			if (methodIdentification == null) {
				methodIdentification = ClassUtils.getQualifiedMethodName(method, targetClass);
			}
		}
		return methodIdentification;
	}

	@Nullable
	protected String methodIdentification(Method method, @Nullable Class<?> targetClass) {
		return null;
	}

	@SuppressWarnings("serial")
	protected TransactionInfo createTransactionIfNecessary(@Nullable PlatformTransactionManager tm,
			@Nullable TransactionAttribute txAttr, final String joinpointIdentification) {

		// If no name specified, apply method identification as transaction name.
		if (txAttr != null && txAttr.getName() == null) {
			txAttr = new DelegatingTransactionAttribute(txAttr) {
				@Override
				public String getName() {
					return joinpointIdentification;
				}
			};
		}

		TransactionStatus status = null;
		if (txAttr != null) {
			if (tm != null) {
				// getTransaction方法开启事务并返回TransactionStatus对象
				status = tm.getTransaction(txAttr);
			}
			else {
				if (logger.isDebugEnabled()) {
					logger.debug("Skipping transactional joinpoint [" + joinpointIdentification +
							"] because no transaction manager has been configured");
				}
			}
		}
		return prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);
	}

	protected TransactionInfo prepareTransactionInfo(@Nullable PlatformTransactionManager tm,
			@Nullable TransactionAttribute txAttr, String joinpointIdentification,
			@Nullable TransactionStatus status) {

		TransactionInfo txInfo = new TransactionInfo(tm, txAttr, joinpointIdentification);
		if (txAttr != null) {
			// We need a transaction for this method...
			if (logger.isTraceEnabled()) {
				logger.trace("Getting transaction for [" + txInfo.getJoinpointIdentification() + "]");
			}
			// The transaction manager will flag an error if an incompatible tx already exists.
			txInfo.newTransactionStatus(status);
		}
		else {
			// The TransactionInfo.hasTransaction() method will return false. We created it only
			// to preserve the integrity of the ThreadLocal stack maintained in this class.
			if (logger.isTraceEnabled())
				logger.trace("Don't need to create transaction for [" + joinpointIdentification +
						"]: This method isn't transactional.");
		}

		// We always bind the TransactionInfo to the thread, even if we didn't create
		// a new transaction here. This guarantees that the TransactionInfo stack
		// will be managed correctly even if no transaction was created by this aspect.
		txInfo.bindToThread();
		return txInfo;
	}

	protected void commitTransactionAfterReturning(@Nullable TransactionInfo txInfo) {
		if (txInfo != null && txInfo.getTransactionStatus() != null) {
			if (logger.isTraceEnabled()) {
				logger.trace("Completing transaction for [" + txInfo.getJoinpointIdentification() + "]");
			}
			txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());
		}
	}

	protected void completeTransactionAfterThrowing(@Nullable TransactionInfo txInfo, Throwable ex) {
		if (txInfo != null && txInfo.getTransactionStatus() != null) {
			if (logger.isTraceEnabled()) {
				logger.trace("Completing transaction for [" + txInfo.getJoinpointIdentification() +
						"] after exception: " + ex);
			}
			// 判断发生的异常是否需要回滚
			if (txInfo.transactionAttribute != null && txInfo.transactionAttribute.rollbackOn(ex)) {
				try {
					txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());
				}
				catch (TransactionSystemException ex2) {
					logger.error("Application exception overridden by rollback exception", ex);
					ex2.initApplicationException(ex);
					throw ex2;
				}
				catch (RuntimeException | Error ex2) {
					logger.error("Application exception overridden by rollback exception", ex);
					throw ex2;
				}
			}
			else {
				// 如果不需要回滚则执行commit
				// We don't roll back on this exception.
				// Will still roll back if TransactionStatus.isRollbackOnly() is true.
				try {
					txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());
				}
				catch (TransactionSystemException ex2) {
					logger.error("Application exception overridden by commit exception", ex);
					ex2.initApplicationException(ex);
					throw ex2;
				}
				catch (RuntimeException | Error ex2) {
					logger.error("Application exception overridden by commit exception", ex);
					throw ex2;
				}
			}
		}
	}

	protected void cleanupTransactionInfo(@Nullable TransactionInfo txInfo) {
		if (txInfo != null) {
			txInfo.restoreThreadLocalStatus();
		}
	}

	protected final class TransactionInfo {

		@Nullable
		private final PlatformTransactionManager transactionManager;

		@Nullable
		private final TransactionAttribute transactionAttribute;

		private final String joinpointIdentification;

		@Nullable
		private TransactionStatus transactionStatus;

		@Nullable
		private TransactionInfo oldTransactionInfo;

		public TransactionInfo(@Nullable PlatformTransactionManager transactionManager,
				@Nullable TransactionAttribute transactionAttribute, String joinpointIdentification) {

			this.transactionManager = transactionManager;
			this.transactionAttribute = transactionAttribute;
			this.joinpointIdentification = joinpointIdentification;
		}

		public PlatformTransactionManager getTransactionManager() {
			Assert.state(this.transactionManager != null, "No PlatformTransactionManager set");
			return this.transactionManager;
		}

		@Nullable
		public TransactionAttribute getTransactionAttribute() {
			return this.transactionAttribute;
		}

		public String getJoinpointIdentification() {
			return this.joinpointIdentification;
		}

		public void newTransactionStatus(@Nullable TransactionStatus status) {
			this.transactionStatus = status;
		}

		@Nullable
		public TransactionStatus getTransactionStatus() {
			return this.transactionStatus;
		}

		public boolean hasTransaction() {
			return (this.transactionStatus != null);
		}

		private void bindToThread() {
			this.oldTransactionInfo = transactionInfoHolder.get();
			transactionInfoHolder.set(this);
		}

		private void restoreThreadLocalStatus() {
			transactionInfoHolder.set(this.oldTransactionInfo);
		}

		@Override
		public String toString() {
			return (this.transactionAttribute != null ? this.transactionAttribute.toString() : "No transaction");
		}
	}

	@FunctionalInterface
	protected interface InvocationCallback {

		Object proceedWithInvocation() throws Throwable;
	}

	private static class ThrowableHolder {

		@Nullable
		public Throwable throwable;
	}

	@SuppressWarnings("serial")
	private static class ThrowableHolderException extends RuntimeException {

		public ThrowableHolderException(Throwable throwable) {
			super(throwable);
		}

		@Override
		public String toString() {
			return getCause().toString();
		}
	}

}
```

[TransactionInterceptor]实现了`invoke()`方法，即实现了事务代理的执行逻辑，而具体实现只是简单的调用`invokeWithinTransaction()`方法，[TransactionInterceptor]的作用相当于将[TransactionAspectSupport]和Spring AOP的逻辑解耦，[TransactionAspectSupport]只需要关心如何执行事务管理即可，代码：
```java
@SuppressWarnings("serial")
public class TransactionInterceptor extends TransactionAspectSupport implements MethodInterceptor, Serializable {
	public TransactionInterceptor() {
	}
	
	public TransactionInterceptor(PlatformTransactionManager ptm, Properties attributes) {
		setTransactionManager(ptm);
		setTransactionAttributes(attributes);
	}

	public TransactionInterceptor(PlatformTransactionManager ptm, TransactionAttributeSource tas) {
		setTransactionManager(ptm);
		setTransactionAttributeSource(tas);
	}


	@Override
	@Nullable
	public Object invoke(final MethodInvocation invocation) throws Throwable {
		// 获取被代理类的类型
		Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);

		return invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);
	}

	private void writeObject(ObjectOutputStream oos) throws IOException {
		oos.defaultWriteObject();

		oos.writeObject(getTransactionManagerBeanName());
		oos.writeObject(getTransactionManager());
		oos.writeObject(getTransactionAttributeSource());
		oos.writeObject(getBeanFactory());
	}

	private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
		ois.defaultReadObject();
		setTransactionManagerBeanName((String) ois.readObject());
		setTransactionManager((PlatformTransactionManager) ois.readObject());
		setTransactionAttributeSource((TransactionAttributeSource) ois.readObject());
		setBeanFactory((BeanFactory) ois.readObject());
	}

}
```

从[TransactionAspectSupport]的实现可以看出，Spring事务执行过程中，`TransactionManager`起了非常重要的作用，下面分析`TransactionManager`的实现，[TransactionAspectSupport]中的`TransactionManager`默认是从[BeanFactory]中获取bean name为`transactionManager`的bean，最开始的例子中使用的`TransactionManager`的实现是[DataSourceTransactionManager]类，该类继承结构如下：
![DataSourceTransactionManager继承结构](../img/DataSourceTransactionManager.png)



[NamespaceHandler]: aaa
[AnnotationDrivenBeanDefinitionParser]: aaa
[AnnotationTransactionAttributeSource]: aaa
[TransactionInterceptor]: aaa
[BeanFactoryTransactionAttributeSourceAdvisor]: aaa
[Advisor]: aaa
[AbstractAdvisorAutoProxyCreator]: aaa
[Pointcut]: aaa
[StaticMethodMatcherPointcut]: aaa
[StaticMethodMatcher]: aaa
[TransactionAttributeSource]: aaa
[TransactionAttribute]: aaa
[RuleBasedTransactionAttribute]: aaa
[TransactionAspectSupport]: aaa
[DataSourceTransactionManager]: aaa