首先看一个事务回滚的测试用例：
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	   xmlns:tx="http://www.springframework.org/schema/tx"
	   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd

       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd">

	<tx:annotation-driven/>

	<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource"/>
	</bean>

	<bean id="bookDao" class="org.springframework.transaction.annotation.dhf.book.dao.impl.JdbcTemplateBookDao">
		<property name="dataSource" ref="dataSource"/>
	</bean>

</beans>
```

```java
public class MyAnnotationTransactionTests {
	ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("org/springframework/transaction/annotation/dhf/MyAnnotationTransactionTests.xml");
	@Test
	public void baseTest() {
		BookDao bookDao = (BookDao) context.getBean("bookDao");
		System.out.println(bookDao.getAll());
	}

	@Test
	public void requestTest() {
		BookDao bookDao = (BookDao) context.getBean("bookDao");
		int count = bookDao.getAll().size();
		System.out.println("count: " + count);

		try {
			System.out.println("insertWithException");
			bookDao.insertWithException(new Book() {{
				setName("test");
				setYear(1);
			}});
		} catch (Exception e) {
			System.out.println(e.getMessage());;
		}

		count = bookDao.getAll().size();
		System.out.println("count: " + count);

		try {
			System.out.println("insert");
			bookDao.insert(new Book() {{
				setName("test");
				setYear(1);
			}});
		} catch (Exception e) {
			e.printStackTrace();
		}

		count = bookDao.getAll().size();
		System.out.println("count: " + count);
	}
}

/*
输出：
count: 5
insertWithException
test insert exception
count: 5
insert
count: 6
*/
```

上面用到的[BookDao]接口及用到的`insert()`和`insertWithException()`方法代码：
```java
@Transactional(propagation = Propagation.REQUIRED)
public interface BookDao {
    void insert(Book book);

    void insertWithException(Book book);

    void insertBatch(List<Book> books);

    void delete(Book book);

    void deleteAll();

    Book getById(Integer id);

    List<Book> getAll();
}

@Override
public void insert(Book book) {
    String sql = "INSERT INTO BOOK(BOOK_ID, NAME, YEAR) VALUES (?, ?, ?)";

    getJdbcTemplate().update(sql, new Object[]{book.getBookId(), book.getName(), book.getYear()});
}
@Override
public void insertWithException(Book book) {
    String sql = "INSERT INTO BOOK(BOOK_ID, NAME, YEAR) VALUES (?, ?, ?)";

    getJdbcTemplate().update(sql, new Object[]{book.getBookId(), book.getName(), book.getYear()});
    throw new RuntimeException("test insert exception");
}
```

可以看到，当insert后抛出异常，数据不会被插入到数据库，即数据库回滚了，而正常执行的insert成功插入了，下面分析Spring中事务的实现原理，首先和AOP一样，先找到XML中`tx`对应的[NamespaceHandler]，其实现是[TxNamespaceHandler]，代码：
```java
public class TxNamespaceHandler extends NamespaceHandlerSupport {

	static final String TRANSACTION_MANAGER_ATTRIBUTE = "transaction-manager";

	// 默认事务管理器的bean name
  static final String DEFAULT_TRANSACTION_MANAGER_BEAN_NAME = "transactionManager";


	static String getTransactionManagerName(Element element) {
		return (element.hasAttribute(TRANSACTION_MANAGER_ATTRIBUTE) ?
				element.getAttribute(TRANSACTION_MANAGER_ATTRIBUTE) : DEFAULT_TRANSACTION_MANAGER_BEAN_NAME);
	}


	@Override
	public void init() {
		registerBeanDefinitionParser("advice", new TxAdviceBeanDefinitionParser());
		registerBeanDefinitionParser("annotation-driven", new AnnotationDrivenBeanDefinitionParser());
		registerBeanDefinitionParser("jta-transaction-manager", new JtaTransactionManagerBeanDefinitionParser());
	}

}
```

`annotation-driven`对应的解析类是[AnnotationDrivenBeanDefinitionParser]，代码：
```java
class AnnotationDrivenBeanDefinitionParser implements BeanDefinitionParser {
	@Override
	@Nullable
	public BeanDefinition parse(Element element, ParserContext parserContext) {
		registerTransactionalEventListenerFactory(parserContext);
		String mode = element.getAttribute("mode");
		if ("aspectj".equals(mode)) {
			// 如果设置mode为aspectj则使用aspectj创建代理
			// mode="aspectj"
			registerTransactionAspect(element, parserContext);
		}
		else {
			// mode="proxy"
			AopAutoProxyConfigurer.configureAutoProxyCreator(element, parserContext);
		}
		return null;
	}

	private void registerTransactionAspect(Element element, ParserContext parserContext) {
		String txAspectBeanName = TransactionManagementConfigUtils.TRANSACTION_ASPECT_BEAN_NAME;
		String txAspectClassName = TransactionManagementConfigUtils.TRANSACTION_ASPECT_CLASS_NAME;
		if (!parserContext.getRegistry().containsBeanDefinition(txAspectBeanName)) {
			RootBeanDefinition def = new RootBeanDefinition();
			def.setBeanClassName(txAspectClassName);
			def.setFactoryMethodName("aspectOf");
			registerTransactionManager(element, def);
			parserContext.registerBeanComponent(new BeanComponentDefinition(def, txAspectBeanName));
		}
	}

	private static void registerTransactionManager(Element element, BeanDefinition def) {
		def.getPropertyValues().add("transactionManagerBeanName",
				TxNamespaceHandler.getTransactionManagerName(element));
	}

	private void registerTransactionalEventListenerFactory(ParserContext parserContext) {
		RootBeanDefinition def = new RootBeanDefinition();
		def.setBeanClass(TransactionalEventListenerFactory.class);
		parserContext.registerBeanComponent(new BeanComponentDefinition(def,
				TransactionManagementConfigUtils.TRANSACTIONAL_EVENT_LISTENER_FACTORY_BEAN_NAME));
	}

	private static class AopAutoProxyConfigurer {
		public static void configureAutoProxyCreator(Element element, ParserContext parserContext) {
			// 事务的实现是基于aop的，这里添加InfrastructureAdvisorAutoProxyCreator的BeanDefinition到BeanFactory，InfrastructureAdvisorAutoProxyCreator
			// 能够将role为ROLE_INFRASTRUCTURE并且实现了Advisor接口的bean添加到aop的可用advisor列表中
			AopNamespaceUtils.registerAutoProxyCreatorIfNecessary(parserContext, element);

			String txAdvisorBeanName = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME;
			if (!parserContext.getRegistry().containsBeanDefinition(txAdvisorBeanName)) {
				Object eleSource = parserContext.extractSource(element);

				// Create the TransactionAttributeSource definition.
				// 注册class为AnnotationTransactionAttributeSource的bean
				RootBeanDefinition sourceDef = new RootBeanDefinition(
						"org.springframework.transaction.annotation.AnnotationTransactionAttributeSource");
				sourceDef.setSource(eleSource);
				sourceDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
				// 注册BeanDefinition到BeanFactory，用DefaultBeanNameGenerator生成bean name，默认为className#0
				String sourceName = parserContext.getReaderContext().registerWithGeneratedName(sourceDef);

				// Create the TransactionInterceptor definition.
				// 注册class为TransactionInterceptor的bean
				RootBeanDefinition interceptorDef = new RootBeanDefinition(TransactionInterceptor.class);
				interceptorDef.setSource(eleSource);
				interceptorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
				// 将<tx:annotation-driven/>中的transaction-manager属性添加到该bean的PropertyValues中，如果没有则默认为transactionManager
				registerTransactionManager(element, interceptorDef);
				// 添加transactionAttributeSource属性为上面注册的AnnotationTransactionAttributeSource的引用
				interceptorDef.getPropertyValues().add("transactionAttributeSource", new RuntimeBeanReference(sourceName));
				String interceptorName = parserContext.getReaderContext().registerWithGeneratedName(interceptorDef);

				// Create the TransactionAttributeSourceAdvisor definition.
				// 注册class为BeanFactoryTransactionAttributeSourceAdvisor的bean，BeanFactoryTransactionAttributeSourceAdvisor实现了Advisor接口
				RootBeanDefinition advisorDef = new RootBeanDefinition(BeanFactoryTransactionAttributeSourceAdvisor.class);
				advisorDef.setSource(eleSource);
				advisorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
				// 添加上面注册的两个bean到下面两个属性中
				advisorDef.getPropertyValues().add("transactionAttributeSource", new RuntimeBeanReference(sourceName));
				advisorDef.getPropertyValues().add("adviceBeanName", interceptorName);
				if (element.hasAttribute("order")) {
					advisorDef.getPropertyValues().add("order", element.getAttribute("order"));
				}
				// 注册BeanDefinition
				parserContext.getRegistry().registerBeanDefinition(txAdvisorBeanName, advisorDef);

				// 发起上面3个BeanDefinition的注册事件
				CompositeComponentDefinition compositeDef = new CompositeComponentDefinition(element.getTagName(), eleSource);
				compositeDef.addNestedComponent(new BeanComponentDefinition(sourceDef, sourceName));
				compositeDef.addNestedComponent(new BeanComponentDefinition(interceptorDef, interceptorName));
				compositeDef.addNestedComponent(new BeanComponentDefinition(advisorDef, txAdvisorBeanName));
				parserContext.registerComponent(compositeDef);
			}
		}
	}

}
```

[AnnotationDrivenBeanDefinitionParser]一共注册了4个[BeanDefinition]，其中[AnnotationTransactionAttributeSource]和[TransactionInterceptor]都被设置为[BeanFactoryTransactionAttributeSourceAdvisor]的属性，所以先从[BeanFactoryTransactionAttributeSourceAdvisor]的代码入手，下面是[BeanFactoryTransactionAttributeSourceAdvisor]的继承结构：
[BeanFactoryTransactionAttributeSourceAdvisor继承结构](!../img/BeanFactoryTransactionAttributeSourceAdvisor.png)

[BeanFactoryTransactionAttributeSourceAdvisor]实现了[Advisor]接口，[AnnotationDrivenBeanDefinitionParser]中注册的[InfrastructureAdvisorAutoProxyCreator]会在创建bean时获取所有实现了[Advisor]接口的Bean以创建其他Bean的代理，所以创建普通Bean时[BeanFactoryTransactionAttributeSourceAdvisor]会被作为[Advisor]参与Bean的代理创建过程，[BeanFactoryTransactionAttributeSourceAdvisor]作为[Advisor]时涉及到的方法有：
```java
private final TransactionAttributeSourcePointcut pointcut = new TransactionAttributeSourcePointcut() {
  @Override
  @Nullable
  protected TransactionAttributeSource getTransactionAttributeSource() {
    return transactionAttributeSource;
  }
};

@Override
public Pointcut getPointcut() {
  return this.pointcut;
}

@Override
public Advice getAdvice() {
  Advice advice = this.advice;
  if (advice != null) {
    return advice;
  }

  // 如果Advice还未初始化则根据adviceBeanName获取Advice
  Assert.state(this.adviceBeanName != null, "'adviceBeanName' must be specified");
  Assert.state(this.beanFactory != null, "BeanFactory must be set to resolve 'adviceBeanName'");

  if (this.beanFactory.isSingleton(this.adviceBeanName)) {
    // Rely on singleton semantics provided by the factory.
    advice = this.beanFactory.getBean(this.adviceBeanName, Advice.class);
    this.advice = advice;
    return advice;
  }
  else {
    // No singleton guarantees from the factory -> let's lock locally but
    // reuse the factory's singleton lock, just in case a lazy dependency
    // of our advice bean happens to trigger the singleton lock implicitly...
    synchronized (this.adviceMonitor) {
      advice = this.advice;
      if (advice == null) {
        advice = this.beanFactory.getBean(this.adviceBeanName, Advice.class);
        this.advice = advice;
      }
      return advice;
    }
  }
}
```

其中`adviceBeanName`属性就是[AnnotationDrivenBeanDefinitionParser]中注册的[TransactionInterceptor]的bean name，从笔记[如何实现AOP](如何实现AOP.md)可知，创建Bean代理之前，[AbstractAdvisorAutoProxyCreator]类的`findEligibleAdvisors()`方法会遍历所有的[Advisor]并过滤掉不匹配正在创建的Bean的[Advisor]，过滤过程会根据[Advisor]的类型执行不同的逻辑，对于[BeanFactoryTransactionAttributeSourceAdvisor]类，其实现了[PointcutAdvisor]接口，所以过滤时会调用[BeanFactoryTransactionAttributeSourceAdvisor]的`getPointcut()`方法获取[Pointcut]并通过[Pointcut]类判断[Advisor]的适用性，而[BeanFactoryTransactionAttributeSourceAdvisor]的[Pointcut]就是[TransactionAttributeSourcePointcut]，

[NamespaceHandler]: aaa
[AnnotationDrivenBeanDefinitionParser]: aaa
[AnnotationTransactionAttributeSource]: aaa
[TransactionInterceptor]: aaa
[BeanFactoryTransactionAttributeSourceAdvisor]: aaa
[Advisor]: aaa
[AbstractAdvisorAutoProxyCreator]: aaa
[Pointcut]: aaa